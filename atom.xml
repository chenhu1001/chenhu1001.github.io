<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clang&#39;s Blog</title>
  
  <subtitle>业精于勤荒于嬉</subtitle>
  <link href="https://www.clang.asia/atom.xml" rel="self"/>
  
  <link href="https://www.clang.asia/"/>
  <updated>2025-10-28T11:39:25.134Z</updated>
  <id>https://www.clang.asia/</id>
  
  <author>
    <name>Clang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一键搭建 WordPress + MySQL + phpMyAdmin 环境（支持 PHP 版本选择 &amp; 自定义配置）</title>
    <link href="https://www.clang.asia/2025/06/08/%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BA-WordPress-MySQL-phpMyAdmin-%E7%8E%AF%E5%A2%83%EF%BC%88%E6%94%AF%E6%8C%81-PHP-%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%EF%BC%89/"/>
    <id>https://www.clang.asia/2025/06/08/%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BA-WordPress-MySQL-phpMyAdmin-%E7%8E%AF%E5%A2%83%EF%BC%88%E6%94%AF%E6%8C%81-PHP-%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%EF%BC%89/</id>
    <published>2025-06-08T16:18:06.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<p>想快速搭建一个 WordPress 环境？这篇文章将带你一步步实现：使用 <code>Docker Compose</code> 一键部署 WordPress、MySQL 和 phpMyAdmin，同时支持指定 PHP 版本和自定义 <code>php.ini</code> 配置。</p><hr><h2 id="✅-功能亮点"><a href="#✅-功能亮点" class="headerlink" title="✅ 功能亮点"></a>✅ 功能亮点</h2><ul><li>🚀 一键启动 WordPress + MySQL + phpMyAdmin</li><li>🧩 可选 PHP 版本（通过自定义 Dockerfile）</li><li>⚙️ 自定义 <code>php.ini</code> 配置</li><li>💾 数据持久化保存到本地目录</li><li>🔐 所有配置开箱即用</li></ul><hr><h2 id="🧱-项目结构"><a href="#🧱-项目结构" class="headerlink" title="🧱 项目结构"></a>🧱 项目结构</h2><p>首先，我们建议使用如下目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├── docker-compose.yml       # 核心 Docker 配置</span><br><span class="line">├── php.ini                  # PHP 自定义设置</span><br><span class="line">├── wordpress/               # WordPress Dockerfile 存放处</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">└── data/                    # 数据卷</span><br><span class="line">    ├── wordpress/           # WordPress 文件（自动生成）</span><br><span class="line">    └── mysql/               # MySQL 数据（自动生成）</span><br></pre></td></tr></table></figure><hr><h2 id="📦-完整-docker-compose-yml"><a href="#📦-完整-docker-compose-yml" class="headerlink" title="📦 完整 docker-compose.yml"></a>📦 完整 <code>docker-compose.yml</code></h2><p>这是本项目的核心配置，定义了三个服务：<code>wordpress</code>、<code>db</code>（MySQL）和 <code>phpmyadmin</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./wordpress</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/wordpress:/var/www/html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./php.ini:/usr/local/etc/php/php.ini</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">wordpress_db</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">rootpassword</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">phpmyadmin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">phpmyadmin/phpmyadmin</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">phpmyadmin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PMA_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">rootpassword</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br></pre></td></tr></table></figure><hr><h2 id="🐘-Dockerfile（选择-PHP-版本）"><a href="#🐘-Dockerfile（选择-PHP-版本）" class="headerlink" title="🐘 Dockerfile（选择 PHP 版本）"></a>🐘 Dockerfile（选择 PHP 版本）</h2><p>你可以使用 WordPress 官方镜像的 PHP 变体，例如 PHP 8.1、8.2 或 7.4：</p><p><strong><code>wordpress/Dockerfile</code></strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 PHP 8.1 的 WordPress 镜像</span></span><br><span class="line"><span class="keyword">FROM</span> wordpress:php8.<span class="number">1</span>-apache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 mysqli 扩展（可按需添加更多扩展）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> docker-php-ext-install mysqli &amp;&amp; docker-php-ext-enable mysqli</span></span><br></pre></td></tr></table></figure><hr><h2 id="⚙️-自定义-php-ini"><a href="#⚙️-自定义-php-ini" class="headerlink" title="⚙️ 自定义 php.ini"></a>⚙️ 自定义 php.ini</h2><p>如果你需要调整上传大小、内存限制等，可以创建一个 <code>php.ini</code> 文件：</p><p><strong><code>php.ini</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upload_max_filesize</span> = <span class="number">1024</span>M</span><br><span class="line"><span class="attr">post_max_size</span> = <span class="number">1024</span>M</span><br><span class="line"><span class="attr">memory_limit</span> = <span class="number">256</span>M</span><br><span class="line"><span class="attr">max_execution_time</span> = <span class="number">300</span></span><br></pre></td></tr></table></figure><p>该文件会在容器中挂载到 <code>/usr/local/etc/php/php.ini</code>，自动生效。</p><hr><h2 id="🚀-启动项目"><a href="#🚀-启动项目" class="headerlink" title="🚀 启动项目"></a>🚀 启动项目</h2><p>确保你已经安装了 Docker 和 Docker Compose，然后在项目根目录运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>启动成功后：</p><ul><li>🖥️ 访问 WordPress：<a href="http://localhost:8080/">http://localhost:8080</a></li><li>🛠️ 访问 phpMyAdmin：<a href="http://localhost:8081（登录用户名">http://localhost:8081（登录用户名</a> <code>root</code>，密码 <code>rootpassword</code>）</li></ul><hr><h2 id="📌-常见问题-amp-提示"><a href="#📌-常见问题-amp-提示" class="headerlink" title="📌 常见问题 &amp; 提示"></a>📌 常见问题 &amp; 提示</h2><ul><li><p><strong>如何更换 PHP 版本？</strong><br>修改 <code>Dockerfile</code> 中的 <code>FROM</code> 行，例如换成 <code>wordpress:php7.4-apache</code>。</p></li><li><p><strong>WordPress 文件修改后不生效？</strong><br>确保 <code>./data/wordpress</code> 目录存在并具有正确权限（尤其是在 Linux 下）。</p></li><li><p><strong>php.ini 没生效？</strong><br>检查是否正确挂载，并重启容器 <code>docker-compose restart wordpress</code>。</p></li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>通过上述配置，你可以快速搭建一个可自定义的 WordPress 环境，无需繁琐手动配置数据库或 PHP 设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想快速搭建一个 WordPress 环境？这篇文章将带你一步步实现：使用 &lt;code&gt;Docker Compose&lt;/code&gt; 一键部署 WordPress、MySQL 和 phpMyAdmin，同时支持指定 PHP 版本和自定义 &lt;code&gt;php.ini&lt;/code&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.clang.asia/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://www.clang.asia/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="WordPress" scheme="https://www.clang.asia/tags/WordPress/"/>
    
  </entry>
  
  <entry>
    <title>AI网址大全</title>
    <link href="https://www.clang.asia/2025/02/16/AI%E7%BD%91%E5%9D%80%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.clang.asia/2025/02/16/AI%E7%BD%91%E5%9D%80%E5%A4%A7%E5%85%A8/</id>
    <published>2025-02-16T15:38:10.000Z</published>
    <updated>2025-10-28T11:39:25.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热门-AI-网站-网页版-："><a href="#热门-AI-网站-网页版-：" class="headerlink" title="热门 AI 网站(网页版)："></a>热门 AI 网站(网页版)：</h1><p><a href="https://www.deepseek.com/">deepseek（深度求索）</a></p><p><a href="https://tongyi.aliyun.com/">Qwen（通义千问）</a></p><p><a href="https://www.doubao.com/chat/">Doubao（豆包）</a></p><p><a href="https://kimi.moonshot.cn/">Kimi(月之暗面)</a></p><p><a href="https://yuanbao.tencent.com/chat/naQivTmsDa">腾讯（混元大模型）</a></p><p><a href="https://zhida.zhihu.com/">知乎直答</a></p><h1 id="第三方部署托管版的deepseek："><a href="#第三方部署托管版的deepseek：" class="headerlink" title="第三方部署托管版的deepseek："></a>第三方部署托管版的deepseek：</h1><p><a href="https://www.ctyun.cn/act/xirang/deepseek">电信版deepseek</a></p><p><a href="https://siliconflow.cn/zh-cn/models">硅基流动deepseek(与华为合作)</a></p><p><a href="https://metaso.cn/">秘塔搜版deepseek</a></p><p><a href="https://bot.n.cn/?src=dh_bj">360(纳米AI搜索)</a></p><h1 id="热门趣味工具"><a href="#热门趣味工具" class="headerlink" title="热门趣味工具:"></a>热门趣味工具:</h1><p><a href="https://www.doubao.com/chat/write">豆包写作专区</a></p><p><a href="https://tongyi.aliyun.com/aippt">PPT创作（通义提供）</a></p><p><a href="https://tongyi.aliyun.com/live/">语音转文字（实时记录）</a></p><p><a href="https://tongyi.aliyun.com/wanxiang/creation">文字作画</a></p><p><a href="https://tongyi.aliyun.com/wanxiang/videoCreation">视频生成</a></p><p><a href="https://www.doubao.com/chat/coding">AI编程（豆包提供）</a></p><h1 id="高手专区（技术玩家进）："><a href="#高手专区（技术玩家进）：" class="headerlink" title="高手专区（技术玩家进）："></a>高手专区（技术玩家进）：</h1><p><a href="https://ollama.com/">ollama（本地部署大模型）</a></p><p><a href="https://dashi.aliyun.com/activity/aigc?userCode=pdtxefg3">打造专属AI应用</a></p><p><a href="https://dashi.aliyun.com/activity/mobi?userCode=pdtxefg3">阿里云AI+ 应用开发平台 </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热门-AI-网站-网页版-：&quot;&gt;&lt;a href=&quot;#热门-AI-网站-网页版-：&quot; class=&quot;headerlink&quot; title=&quot;热门 AI 网站(网页版)：&quot;&gt;&lt;/a&gt;热门 AI 网站(网页版)：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.d</summary>
      
    
    
    
    <category term="AI" scheme="https://www.clang.asia/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.clang.asia/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>基于C++线程延迟处理的 ROS 消息逻辑优化</title>
    <link href="https://www.clang.asia/2024/11/20/%E5%9F%BA%E4%BA%8EC-%E7%BA%BF%E7%A8%8B%E5%BB%B6%E8%BF%9F%E5%A4%84%E7%90%86%E7%9A%84-ROS-%E6%B6%88%E6%81%AF%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96/"/>
    <id>https://www.clang.asia/2024/11/20/%E5%9F%BA%E4%BA%8EC-%E7%BA%BF%E7%A8%8B%E5%BB%B6%E8%BF%9F%E5%A4%84%E7%90%86%E7%9A%84-ROS-%E6%B6%88%E6%81%AF%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96/</id>
    <published>2024-11-20T06:46:27.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于线程延迟处理的-ROS-消息逻辑优化"><a href="#基于线程延迟处理的-ROS-消息逻辑优化" class="headerlink" title="基于线程延迟处理的 ROS 消息逻辑优化"></a><strong>基于线程延迟处理的 ROS 消息逻辑优化</strong></h3><p>在 ROS 开发中，我们常常需要对某些消息的处理逻辑进行优化。例如，某个话题的消息可能会频繁发布，而我们希望在消息连续时推迟某些操作，只有在消息停止后一定时间才触发特定逻辑。这种场景可以通过线程延迟处理机制实现。</p><p>本文以一个电笛控制系统为例，讲解如何通过线程延迟机制优化 ROS 的消息处理逻辑。</p><hr><h4 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a><strong>需求场景</strong></h4><ul><li>话题 <code>/electric_horn</code> 的消息以 <code>std_msgs::Bool</code> 类型发布，表示是否按下电笛按钮。</li><li>当消息连续时，不执行心跳操作 <code>HeartBeat</code>。</li><li>当最后一条消息超过 1 秒未更新时，触发 <code>HeartBeat</code>。</li></ul><hr><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h3><ol><li><p><strong>延迟触发机制</strong><br>通过记录最近一次收到消息的时间，启动一个独立的线程监控消息间隔。只有当消息停止（超过 1 秒未更新）后，才触发 <code>HeartBeat</code> 操作。</p></li><li><p><strong>线程控制</strong><br>使用 <code>std::thread</code> 来实现延迟触发逻辑，同时通过 <code>std::atomic</code> 控制线程的启动和停止，避免多线程竞态。</p></li><li><p><strong>ROS消息回调逻辑</strong><br>每次收到新消息时，更新最新时间并终止之前的延迟线程，重新启动监控逻辑。</p></li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><h4 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a><strong>类成员变量</strong></h4><p>在 <code>TowerController</code> 类中，定义以下变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TowerController</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::steady_clock::time_point lastMessageTime_; <span class="comment">// 最近消息的时间</span></span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; delayThread_;             <span class="comment">// 延迟处理的线程</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stopDelayThread_;                    <span class="comment">// 控制线程停止的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressElectricHornCallback</span><span class="params">(<span class="type">const</span> std_msgs::Bool::ConstPtr&amp; press)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ElectricHorn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HeartBeat</span><span class="params">(<span class="type">bool</span> active)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a><strong>构造函数与析构函数</strong></h4><p>初始化时间点和线程控制变量，并确保析构时安全退出线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TowerController::<span class="built_in">TowerController</span>() &#123;</span><br><span class="line">    lastMessageTime_ = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    stopDelayThread_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TowerController::~<span class="built_in">TowerController</span>() &#123;</span><br><span class="line">    stopDelayThread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (delayThread_ &amp;&amp; delayThread_-&gt;<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        delayThread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息回调函数"><a href="#消息回调函数" class="headerlink" title="消息回调函数"></a><strong>消息回调函数</strong></h4><p>每次接收到消息时，更新最新时间，终止之前的延迟线程并启动新的监控线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TowerController::PressElectricHornCallback</span><span class="params">(<span class="type">const</span> std_msgs::Bool::ConstPtr&amp; press)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (press-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">INFO</span>(<span class="string">&quot;收到电笛按钮按下信号&quot;</span>);</span><br><span class="line">        ctThread-&gt;<span class="built_in">Enqueue</span>(std::<span class="built_in">bind</span>(&amp;TowerController::ElectricHorn, <span class="keyword">this</span>)); <span class="comment">// 异步处理电笛逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最后一次收到消息的时间</span></span><br><span class="line">        lastMessageTime_ = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止现有的延迟线程</span></span><br><span class="line">        stopDelayThread_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (delayThread_ &amp;&amp; delayThread_-&gt;<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            delayThread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stopDelayThread_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动新的延迟线程</span></span><br><span class="line">        delayThread_ = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;([<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stopDelayThread_) &#123;</span><br><span class="line">                <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">                <span class="keyword">if</span> (std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastMessageTime_).<span class="built_in">count</span>() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">INFO</span>(<span class="string">&quot;消息间隔超过1秒，触发心跳信号&quot;</span>);</span><br><span class="line">                    <span class="built_in">HeartBeat</span>(<span class="literal">true</span>); <span class="comment">// 触发心跳操作</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电笛逻辑"><a href="#电笛逻辑" class="headerlink" title="电笛逻辑"></a><strong>电笛逻辑</strong></h4><p>保持 <code>ElectricHorn</code> 的核心逻辑不变，负责单纯的电笛控制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TowerController::ElectricHorn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;电笛按钮被触发&quot;</span>);</span><br><span class="line">    <span class="built_in">ElectricHornControl</span>();      <span class="comment">// 执行电笛硬件控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优化点与注意事项"><a href="#优化点与注意事项" class="headerlink" title="优化点与注意事项"></a><strong>优化点与注意事项</strong></h3><ol><li><p><strong>避免线程泄漏</strong><br>每次启动新的延迟线程前，确保之前的线程安全退出（使用 <code>join</code>）。</p></li><li><p><strong>提高线程效率</strong><br>使用 <code>std::this_thread::sleep_for</code> 来减少线程对 CPU 的占用，同时避免繁忙轮询。</p></li><li><p><strong>多线程安全性</strong><br>使用 <code>std::atomic</code> 来控制线程停止标志，避免线程间的数据竞争。</p></li><li><p><strong>可维护性</strong><br>将 <code>HeartBeat</code> 的触发逻辑外部化，确保核心功能（如 <code>ElectricHorn</code>）独立，逻辑清晰。</p></li></ol><hr><h3 id="完整效果"><a href="#完整效果" class="headerlink" title="完整效果"></a><strong>完整效果</strong></h3><ul><li>在消息频繁时，只执行电笛控制逻辑，不触发心跳信号。</li><li>当最后一条消息超过 1 秒未更新后，延迟线程触发心跳信号。</li><li>避免频繁触发心跳信号，提高系统效率。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过线程延迟机制，我们可以优雅地解决 ROS 消息的连续处理问题。这种模式不仅适用于电笛控制系统，还可以推广到其他需要延迟触发的场景，如报警信号、状态同步等。</p><p>使用延迟线程结合时间点记录，既保证了实时性，又提升了系统的灵活性，是一种实用且高效的设计模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基于线程延迟处理的-ROS-消息逻辑优化&quot;&gt;&lt;a href=&quot;#基于线程延迟处理的-ROS-消息逻辑优化&quot; class=&quot;headerlink&quot; title=&quot;基于线程延迟处理的 ROS 消息逻辑优化&quot;&gt;&lt;/a&gt;&lt;strong&gt;基于线程延迟处理的 ROS 消息逻辑</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
    <category term="C++" scheme="https://www.clang.asia/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 运行 Node.js：无需依赖系统版本，快速切换、环境隔离</title>
    <link href="https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-Node-js%EF%BC%9A%E6%97%A0%E9%9C%80%E4%BE%9D%E8%B5%96%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E3%80%81%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB/"/>
    <id>https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-Node-js%EF%BC%9A%E6%97%A0%E9%9C%80%E4%BE%9D%E8%B5%96%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E3%80%81%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB/</id>
    <published>2024-11-19T10:21:15.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-Docker-运行-Node-js：无需依赖系统版本，快速切换、环境隔离"><a href="#使用-Docker-运行-Node-js：无需依赖系统版本，快速切换、环境隔离" class="headerlink" title="使用 Docker 运行 Node.js：无需依赖系统版本，快速切换、环境隔离"></a><strong>使用 Docker 运行 Node.js：无需依赖系统版本，快速切换、环境隔离</strong></h3><p>在开发 Node.js 应用时，很多开发者会遇到一个问题：<strong>系统中的 Node.js 版本不支持最新功能，或者需要在多个版本之间频繁切换</strong>。传统方式需要手动安装和配置，这不仅费时，还容易污染系统环境。借助 <strong>Docker</strong>，你可以轻松解决这些问题。</p><p>本文将以一个实际案例展示如何使用 Docker 快速运行 <strong>Node.js 20</strong>，实现系统版本无关性、动态版本切换和环境隔离。</p><hr><h3 id="为什么使用-Docker-运行-Node-js？"><a href="#为什么使用-Docker-运行-Node-js？" class="headerlink" title="为什么使用 Docker 运行 Node.js？"></a><strong>为什么使用 Docker 运行 Node.js？</strong></h3><ol><li><p><strong>系统版本无关性</strong><br>无需关心操作系统是否支持特定版本的 Node.js（例如在 CentOS 7 上运行最新版本的 Node.js），一切都由 Docker 容器管理。</p></li><li><p><strong>动态版本切换</strong><br>Docker 镜像支持不同版本的 Node.js，切换版本只需更改镜像标签（如 <code>node:18</code>、<code>node:20</code>）。</p></li><li><p><strong>环境隔离</strong><br>容器中的 Node.js 环境独立于主机系统，避免版本冲突或环境污染。</p></li><li><p><strong>便捷共享</strong><br>使用容器共享开发环境，只需一条命令，团队成员就能快速运行一致的环境。</p></li></ol><hr><h3 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a><strong>核心命令</strong></h3><p>以下是我们将在教程中使用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it --name node-container-20 -v $(<span class="built_in">pwd</span>):/app -w /app -p 4000:4000 node:20 bash</span><br></pre></td></tr></table></figure><p>这条命令启动一个基于 <strong>Node.js 20</strong> 的容器，配置了文件挂载、端口映射、环境隔离等功能。以下是详细解析。</p><hr><h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a><strong>命令详解</strong></h3><h4 id="1-系统版本无关性：使用-Docker-镜像"><a href="#1-系统版本无关性：使用-Docker-镜像" class="headerlink" title="1. 系统版本无关性：使用 Docker 镜像"></a>1. 系统版本无关性：使用 Docker 镜像</h4><ul><li><strong><code>node:20</code></strong> 指定 Node.js 的版本为 20。</li><li>Docker 自动从官方仓库中拉取对应版本的 Node.js 镜像，镜像包含了运行时环境和必要依赖，无需考虑系统是否支持。</li></ul><h4 id="2-动态切换版本"><a href="#2-动态切换版本" class="headerlink" title="2. 动态切换版本"></a>2. 动态切换版本</h4><ul><li>如果需要切换到其他版本，只需替换镜像标签。例如切换到 Node.js 18：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it --name node-container-18 -v $(<span class="built_in">pwd</span>):/app -w /app -p 4000:4000 node:18 bash</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-环境隔离与便捷性"><a href="#3-环境隔离与便捷性" class="headerlink" title="3. 环境隔离与便捷性"></a>3. 环境隔离与便捷性</h4><ul><li><strong>隔离</strong>：容器中的 Node.js 独立运行，不影响主机系统。无论主机是否安装了 Node.js，都可以正常运行。</li><li><strong>临时运行</strong>：使用 <code>--rm</code> 参数，容器退出后会自动删除，不留痕迹，保持系统干净。</li></ul><h4 id="4-文件挂载与共享"><a href="#4-文件挂载与共享" class="headerlink" title="4. 文件挂载与共享"></a>4. 文件挂载与共享</h4><ul><li><strong><code>-v $(pwd):/app</code></strong> 将主机当前目录挂载到容器的 <code>/app</code> 目录，主机和容器间共享文件。主机修改的代码会立即反映在容器中。</li></ul><h4 id="5-端口映射"><a href="#5-端口映射" class="headerlink" title="5. 端口映射"></a>5. 端口映射</h4><ul><li><strong><code>-p 4000:4000</code></strong> 将宿主机的 4000 端口映射到容器的 4000 端口，方便在主机上直接访问容器内运行的服务。</li></ul><hr><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a><strong>实际操作</strong></h3><h4 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1. 运行容器"></a>1. 运行容器</h4><p>在项目目录运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it --name node-container-20 -v $(<span class="built_in">pwd</span>):/app -w /app -p 4000:4000 node:20 bash</span><br></pre></td></tr></table></figure><h4 id="2-容器中的操作"><a href="#2-容器中的操作" class="headerlink" title="2. 容器中的操作"></a>2. 容器中的操作</h4><p>进入容器后，终端会显示类似以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@&lt;container-id&gt;:/app#</span><br></pre></td></tr></table></figure><p>此时，你可以在容器中执行 Node.js 相关命令。例如：</p><ul><li><p>检查 Node.js 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v20.x.x</span><br></pre></td></tr></table></figure></li><li><p>运行简单的 HTTP 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;const http = require(&#x27;http&#x27;);&quot;</span> &gt; server.js</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;http.createServer((req, res) =&gt; res.end(&#x27;Hello, Docker!&#x27;)).listen(4000);&quot;</span> &gt;&gt; server.js</span><br><span class="line">node server.js</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-宿主机访问服务"><a href="#3-宿主机访问服务" class="headerlink" title="3. 宿主机访问服务"></a>3. 宿主机访问服务</h4><p>在浏览器中访问 <code>http://localhost:4000</code> 或通过 <code>curl</code> 测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:4000</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Docker!</span><br></pre></td></tr></table></figure><h4 id="4-退出容器"><a href="#4-退出容器" class="headerlink" title="4. 退出容器"></a>4. 退出容器</h4><p>输入 <code>exit</code> 即可退出容器，容器会自动清理（由于我们使用了 <code>--rm</code> 参数）。</p><hr><h3 id="灵活切换和持久化环境"><a href="#灵活切换和持久化环境" class="headerlink" title="灵活切换和持久化环境"></a><strong>灵活切换和持久化环境</strong></h3><h4 id="切换-Node-js-版本"><a href="#切换-Node-js-版本" class="headerlink" title="切换 Node.js 版本"></a><strong>切换 Node.js 版本</strong></h4><p>如需运行不同版本，只需修改镜像标签。例如运行 Node.js 16：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it --name node-container-16 -v $(<span class="built_in">pwd</span>):/app -w /app -p 4000:4000 node:16 bash</span><br></pre></td></tr></table></figure><h4 id="持久化容器"><a href="#持久化容器" class="headerlink" title="持久化容器"></a><strong>持久化容器</strong></h4><p>如果希望容器退出后仍能保存环境和数据，可去掉 <code>--rm</code> 参数，并重新启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name node-container-20 -v $(<span class="built_in">pwd</span>):/app -w /app -p 4000:4000 node:20 bash</span><br></pre></td></tr></table></figure><p>退出后可以重新启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start -ai node-container-20</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 Docker 运行 Node.js 环境，可以完全摆脱对系统版本的依赖，轻松切换不同版本，实现开发环境的快速搭建和隔离。<br>无论你是想在老旧系统（如 CentOS 7）上使用最新的 Node.js，还是需要在多个项目间切换 Node.js 版本，Docker 都能为你提供高效的解决方案。  </p><p>赶快试试这个方法，让你的开发更高效、更干净！🎉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用-Docker-运行-Node-js：无需依赖系统版本，快速切换、环境隔离&quot;&gt;&lt;a href=&quot;#使用-Docker-运行-Node-js：无需依赖系统版本，快速切换、环境隔离&quot; class=&quot;headerlink&quot; title=&quot;使用 Docker 运行 N</summary>
      
    
    
    
    <category term="运维" scheme="https://www.clang.asia/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://www.clang.asia/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程编程与进程间通信</title>
    <link href="https://www.clang.asia/2024/11/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.clang.asia/2024/11/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2024-11-19T06:44:05.000Z</published>
    <updated>2025-10-28T11:39:25.131Z</updated>
    
    <content type="html"><![CDATA[<p>Python的多进程编程是通过multiprocessing模块来实现的，利用多进程可以有效地提高程序的运行效率。然而，在多进程编程中，进程间的通信是一个非常重要的问题。本文将介绍Python多进程编程的基础知识，并重点讨论进程间的通信方法，包括队列、管道和共享内存。</p><h1 id="Python多进程编程基础"><a href="#Python多进程编程基础" class="headerlink" title="Python多进程编程基础"></a>Python多进程编程基础</h1><p>Python的多进程编程主要通过multiprocessing模块来实现。该模块提供了一个Process类，用于创建新的进程。下面是一个简单的多进程编程例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> is working...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟一些工作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建多个进程</span></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程完成</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了5个进程，每个进程执行worker函数。主进程等待所有进程完成后，程序结束。<br>进程间通信<br>在多进程编程中，进程间的通信是一个非常重要的问题。Python的multiprocessing模块提供了几种进程间通信的方法，包括队列、管道和共享内存。</p><h2 id="1-队列（Queue）"><a href="#1-队列（Queue）" class="headerlink" title="1. 队列（Queue）"></a>1. 队列（Queue）</h2><p>队列是最常用的进程间通信方法之一。队列是一种先进先出的数据结构，进程可以将数据放入队列中，其他进程可以从队列中取出数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker is working...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟一些工作</span></span><br><span class="line">    result = <span class="string">&quot;Worker finished&quot;</span></span><br><span class="line">    queue.put(result)  <span class="comment"># 将结果放入队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建工作进程</span></span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(queue,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待工作进程完成</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从队列中获取结果</span></span><br><span class="line">    result = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="2-管道（Pipe）"><a href="#2-管道（Pipe）" class="headerlink" title="2. 管道（Pipe）"></a>2. 管道（Pipe）</h2><p>管道是另一种进程间通信方法。管道是一种半双工的通信方式，数据只能在一个方向上流动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker is working...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟一些工作</span></span><br><span class="line">    result = <span class="string">&quot;Worker finished&quot;</span></span><br><span class="line">    conn.send(result)  <span class="comment"># 发送结果</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建管道</span></span><br><span class="line">    parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建工作进程</span></span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待工作进程完成</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收结果</span></span><br><span class="line">    result = parent_conn.recv()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    parent_conn.close()</span><br></pre></td></tr></table></figure><h2 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. 共享内存（Shared Memory）</h2><p>共享内存是进程间通信的另一种方法。共享内存允许多个进程访问同一块内存区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">shared_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker is working...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟一些工作</span></span><br><span class="line">    shared_list.append(<span class="string">&quot;Worker finished&quot;</span>)  <span class="comment"># 修改共享列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建共享列表</span></span><br><span class="line">    manager = multiprocessing.Manager()</span><br><span class="line">    shared_list = manager.<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建工作进程</span></span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(shared_list,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待工作进程完成</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印共享列表</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(shared_list))</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Python的多进程编程是通过multiprocessing模块来实现的，利用多进程可以有效地提高程序的运行效率。进程间的通信是一个非常重要的问题，Python提供了队列、管道和共享内存等方法来实现进程间的通信。每种方法都有其优缺点，选择哪种方法取决于具体的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python的多进程编程是通过multiprocessing模块来实现的，利用多进程可以有效地提高程序的运行效率。然而，在多进程编程中，进程间的通信是一个非常重要的问题。本文将介绍Python多进程编程的基础知识，并重点讨论进程间的通信方法，包括队列、管道和共享内存。&lt;/p</summary>
      
    
    
    
    <category term="Python" scheme="https://www.clang.asia/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.clang.asia/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 FastAPI 的 @app.on_event(“startup“) 中启动后台线程</title>
    <link href="https://www.clang.asia/2024/11/19/%E5%9C%A8-FastAPI-%E7%9A%84-app-on-event-%E2%80%9Cstartup%E2%80%9C-%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.clang.asia/2024/11/19/%E5%9C%A8-FastAPI-%E7%9A%84-app-on-event-%E2%80%9Cstartup%E2%80%9C-%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-11-19T06:43:58.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在-FastAPI-的-app-on-event-quot-startup-quot-中启动后台线程"><a href="#在-FastAPI-的-app-on-event-quot-startup-quot-中启动后台线程" class="headerlink" title="在 FastAPI 的 @app.on_event(&quot;startup&quot;) 中启动后台线程"></a>在 FastAPI 的 <code>@app.on_event(&quot;startup&quot;)</code> 中启动后台线程</h3><p>在 FastAPI 项目中，某些任务可能需要在应用启动时运行，并在后台持续执行，如定时清理数据库、监控资源或定时获取数据等。为此，我们可以在 FastAPI 的 <code>@app.on_event(&quot;startup&quot;)</code> 中启动后台线程，确保应用在启动后立刻开始这些任务。</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>FastAPI 是一个支持异步编程的 Python Web 框架，运行在异步事件循环上，能够高效处理 I&#x2F;O 密集型任务。不过，在应用启动的过程中，有些任务（如 CPU 密集型任务）更适合使用传统的多线程来异步执行，以避免阻塞主事件循环。这时，可以使用 Python 标准库的 <code>threading</code> 模块，结合 <code>@app.on_event(&quot;startup&quot;)</code> 启动线程，以便在后台执行这些任务。</p><h3 id="在-startup-中启动后台线程的方式"><a href="#在-startup-中启动后台线程的方式" class="headerlink" title="在 startup 中启动后台线程的方式"></a>在 <code>startup</code> 中启动后台线程的方式</h3><p>有几种方式可以在 <code>startup</code> 中启动后台线程，以下是几种常见的方法。</p><h4 id="1-使用-threading-Thread-启动后台线程"><a href="#1-使用-threading-Thread-启动后台线程" class="headerlink" title="1. 使用 threading.Thread 启动后台线程"></a>1. 使用 <code>threading.Thread</code> 启动后台线程</h4><p><code>threading.Thread</code> 是 Python 标准库提供的多线程模块，可以在启动应用时启动一个守护线程，让它在后台运行。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">background_task</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Running background task...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">10</span>)  <span class="comment"># 模拟一个需要重复执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;startup&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">startup</span>():</span><br><span class="line">    <span class="comment"># 创建并启动一个守护线程，以便在应用启动时开始执行后台任务</span></span><br><span class="line">    thread = threading.Thread(target=background_task, daemon=<span class="literal">True</span>)</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Background thread has started.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;shutdown&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shutdown</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Application is shutting down.&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong>守护线程</strong>：<code>daemon=True</code> 表示该线程是守护线程，应用关闭时不会等待该线程结束，确保应用可以快速关闭。</li><li><strong>持续运行</strong>：<code>background_task</code> 函数中的 <code>while True</code> 循环使得该线程持续执行，可以通过 <code>time.sleep()</code> 控制任务的频率。</li></ul><h4 id="2-使用-concurrent-futures-ThreadPoolExecutor-启动线程池"><a href="#2-使用-concurrent-futures-ThreadPoolExecutor-启动线程池" class="headerlink" title="2. 使用 concurrent.futures.ThreadPoolExecutor 启动线程池"></a>2. 使用 <code>concurrent.futures.ThreadPoolExecutor</code> 启动线程池</h4><p>如果有多个后台任务需要并行运行，<code>concurrent.futures.ThreadPoolExecutor</code> 是更好的选择，它可以创建一个线程池来管理多个后台任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_one</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Running task one...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_two</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Running task two...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;startup&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">startup</span>():</span><br><span class="line">    <span class="comment"># 使用线程池启动多个后台任务</span></span><br><span class="line">    executor.submit(task_one)</span><br><span class="line">    executor.submit(task_two)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Background tasks have started.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;shutdown&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shutdown</span>():</span><br><span class="line">    executor.shutdown(wait=<span class="literal">False</span>)  <span class="comment"># 停止所有后台任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Application is shutting down.&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong>多个任务</strong>：每个任务可以独立定义，并通过 <code>executor.submit()</code> 添加到线程池。</li><li><strong>线程池</strong>：<code>ThreadPoolExecutor</code> 会自动管理线程，最大线程数通过 <code>max_workers</code> 控制。</li></ul><h4 id="3-使用-asyncio-create-task-启动异步任务"><a href="#3-使用-asyncio-create-task-启动异步任务" class="headerlink" title="3. 使用 asyncio.create_task 启动异步任务"></a>3. 使用 <code>asyncio.create_task</code> 启动异步任务</h4><p>如果任务是异步的，可以使用 <code>asyncio.create_task</code> 启动一个异步任务，这样就不需要创建新的线程。异步任务适合用于 I&#x2F;O 密集型操作，比如网络请求、数据库访问等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_background_task</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Running async background task...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;startup&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">startup</span>():</span><br><span class="line">    <span class="comment"># 使用 asyncio 启动异步任务</span></span><br><span class="line">    asyncio.create_task(async_background_task())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Async background task has started.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_event(<span class="params"><span class="string">&quot;shutdown&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shutdown</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Application is shutting down.&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><strong>异步任务</strong>：<code>async_background_task</code> 使用 <code>async def</code> 声明，是一个异步函数。</li><li><strong>事件循环</strong>：<code>asyncio.create_task</code> 在主事件循环上创建任务，而不需要额外线程。这对 I&#x2F;O 密集型任务非常高效，因为异步任务会在等待 I&#x2F;O 操作时让出控制权，不会阻塞主线程。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>守护线程</strong>：确保后台线程设置为守护线程（<code>daemon=True</code>），否则 FastAPI 关闭时会等待线程结束。</li><li><strong>资源清理</strong>：在 <code>@app.on_event(&quot;shutdown&quot;)</code> 中执行清理操作，如释放数据库连接、关闭文件等，防止资源泄露。</li><li><strong>选择合适的方式</strong>：根据任务类型选择合适的实现方式：<ul><li>I&#x2F;O 密集型任务使用 <code>asyncio.create_task</code> 启动异步任务。</li><li>CPU 密集型任务使用 <code>threading.Thread</code> 启动后台线程。</li><li>多个并发任务使用 <code>ThreadPoolExecutor</code> 来管理。</li></ul></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在 FastAPI 中启动后台线程，可以帮助我们实现一些自动化或定时操作，确保在应用启动时即开始执行这些任务。选择适合的方式可以使后台任务更加高效，同时减少对主线程的影响，从而提升应用的响应速度。希望本文帮助大家理解在 FastAPI 中启动后台线程的不同方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;在-FastAPI-的-app-on-event-quot-startup-quot-中启动后台线程&quot;&gt;&lt;a href=&quot;#在-FastAPI-的-app-on-event-quot-startup-quot-中启动后台线程&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Python" scheme="https://www.clang.asia/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.clang.asia/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用 asyncio.run_coroutine_threadsafe 在 Python 中处理异步操作</title>
    <link href="https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8-asyncio-run-coroutine-threadsafe-%E5%9C%A8-Python-%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8-asyncio-run-coroutine-threadsafe-%E5%9C%A8-Python-%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2024-11-19T06:43:50.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-asyncio-run-coroutine-threadsafe-在-Python-中处理异步操作"><a href="#使用-asyncio-run-coroutine-threadsafe-在-Python-中处理异步操作" class="headerlink" title="使用 asyncio.run_coroutine_threadsafe 在 Python 中处理异步操作"></a>使用 <code>asyncio.run_coroutine_threadsafe</code> 在 Python 中处理异步操作</h3><p>在现代 Python 开发中，异步编程已经成为一种常见的模式。尤其是在处理 I&#x2F;O 密集型操作（如网络请求或文件读写）时，异步编程能够显著提高程序的性能。本文将介绍如何使用 <code>asyncio.run_coroutine_threadsafe</code> 方法来在多线程环境中安全地调度异步操作。</p><h4 id="什么是-asyncio-run-coroutine-threadsafe？"><a href="#什么是-asyncio-run-coroutine-threadsafe？" class="headerlink" title="什么是 asyncio.run_coroutine_threadsafe？"></a>什么是 <code>asyncio.run_coroutine_threadsafe</code>？</h4><p><code>asyncio.run_coroutine_threadsafe</code> 是 <code>asyncio</code> 库中的一个实用函数，它允许在与事件循环不在同一线程的情况下安全地调度异步协程。这对于在多线程程序中使用异步操作非常重要，因为直接从非事件循环线程调用协程会导致错误。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>想象一个场景，你有一个主线程在运行一个 ROS 节点，它需要处理来自外部线程的请求。这时，你可能希望在 ROS 节点的事件循环中执行一些异步操作。这里就是 <code>asyncio.run_coroutine_threadsafe</code> 的用武之地。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个示例，展示如何使用 <code>asyncio.run_coroutine_threadsafe</code> 来调度异步操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncWorker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_task</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始异步任务&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟长时间运行的异步操作</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;异步任务完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_async_task</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 在主线程中调度异步任务</span></span><br><span class="line">        asyncio.run_coroutine_threadsafe(<span class="variable language_">self</span>.async_task(), <span class="variable language_">self</span>.loop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_function</span>(<span class="params">worker</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;线程启动&quot;</span>)</span><br><span class="line">    worker.run_async_task()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;线程结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    worker = AsyncWorker()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动新线程</span></span><br><span class="line">    thread = threading.Thread(target=thread_function, args=(worker,))</span><br><span class="line">    thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保持事件循环运行</span></span><br><span class="line">    worker.loop.run_forever()</span><br></pre></td></tr></table></figure><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><p><strong>创建事件循环</strong>：在 <code>AsyncWorker</code> 类中，我们首先获取事件循环 <code>self.loop</code>。</p></li><li><p><strong>定义异步任务</strong>：<code>async_task</code> 方法是一个异步协程，模拟了一个需要2秒的耗时操作。</p></li><li><p><strong>调度异步任务</strong>：<code>run_async_task</code> 方法中，我们使用 <code>asyncio.run_coroutine_threadsafe</code> 将 <code>async_task</code> 调度到事件循环中。即使在另一个线程中调用它也不会引发错误。</p></li><li><p><strong>多线程环境</strong>：在 <code>thread_function</code> 中，我们启动一个新线程并调用 <code>run_async_task</code>。主线程则保持事件循环运行。</p></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p><strong>线程安全</strong>：<code>asyncio.run_coroutine_threadsafe</code> 是线程安全的，它会将任务放入事件循环的队列中。</p></li><li><p><strong>错误处理</strong>：在实际应用中，建议对异步任务添加适当的异常处理，以避免未捕获的错误导致程序崩溃。</p></li><li><p><strong>性能考虑</strong>：在多线程和异步的混合使用中，要注意线程的开销，确保使用这些技术确实能带来性能提升。</p></li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><code>asyncio.run_coroutine_threadsafe</code> 是在多线程环境中安全地调度异步操作的强大工具。通过合理使用它，可以提高程序的响应性和性能。希望本文能帮助你更好地理解和应用这一技术，让你的异步编程更加高效！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用-asyncio-run-coroutine-threadsafe-在-Python-中处理异步操作&quot;&gt;&lt;a href=&quot;#使用-asyncio-run-coroutine-threadsafe-在-Python-中处理异步操作&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Python" scheme="https://www.clang.asia/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.clang.asia/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用GeographicLib在C++中进行地理坐标转换</title>
    <link href="https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8GeographicLib%E5%9C%A8C-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.clang.asia/2024/11/19/%E4%BD%BF%E7%94%A8GeographicLib%E5%9C%A8C-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</id>
    <published>2024-11-19T06:03:53.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用GeographicLib在C-中进行地理坐标转换"><a href="#使用GeographicLib在C-中进行地理坐标转换" class="headerlink" title="使用GeographicLib在C++中进行地理坐标转换"></a>使用GeographicLib在C++中进行地理坐标转换</h3><p>在现代软件开发中，经常需要处理地理坐标转换问题，例如将经纬度转换为局部直角坐标系。GeographicLib是一个强大的开源库，提供了便捷的工具来进行这些转换。本文将介绍如何在C++项目中使用GeographicLib进行地理坐标转换的步骤和示例代码。</p><h4 id="步骤一：安装GeographicLib"><a href="#步骤一：安装GeographicLib" class="headerlink" title="步骤一：安装GeographicLib"></a>步骤一：安装GeographicLib</h4><p>首先，确保你的系统中已安装GeographicLib库。可以通过以下命令在Ubuntu中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install geographiclib-*   <span class="comment"># 安装GeographicLib的库</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install libgeographic-*  <span class="comment"># 安装GeographicLib的依赖库</span></span><br></pre></td></tr></table></figure><h4 id="步骤二：配置C-项目"><a href="#步骤二：配置C-项目" class="headerlink" title="步骤二：配置C++项目"></a>步骤二：配置C++项目</h4><p>在你的C++项目中，需要配置CMake以及链接GeographicLib库。<br>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(my_test_project LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含GeographicLib的头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;/usr/include/GeographicLib&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接GeographicLib库（根据你的安装调整库名）</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Geographic)</span><br></pre></td></tr></table></figure><h4 id="步骤三：示例代码"><a href="#步骤三：示例代码" class="headerlink" title="步骤三：示例代码"></a>步骤三：示例代码</h4><p>以下是一个简单的示例代码，演示了如何使用GeographicLib将经纬度转换为局部直角坐标系：<br>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GeographicLib/LocalCartesian.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前点的经纬度和高度，作为局部坐标系的原点</span></span><br><span class="line">    <span class="type">double</span> origin_latitude = <span class="number">29.116543</span>;   <span class="comment">// 纬度</span></span><br><span class="line">    <span class="type">double</span> origin_longitude = <span class="number">111.506270</span>; <span class="comment">// 经度</span></span><br><span class="line">    <span class="type">double</span> origin_height = <span class="number">0.0</span>;           <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 LocalCartesian 对象，并设置原点</span></span><br><span class="line">    GeographicLib::LocalCartesian geoConverter;</span><br><span class="line">    geoConverter.<span class="built_in">Reset</span>(origin_latitude, origin_longitude, origin_height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要转换的另一个点的经纬度和高度</span></span><br><span class="line">    <span class="type">double</span> target_latitude = <span class="number">29.106543</span>;</span><br><span class="line">    <span class="type">double</span> target_longitude = <span class="number">111.606270</span>;</span><br><span class="line">    <span class="type">double</span> target_height = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为局部直角坐标系</span></span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    geoConverter.<span class="built_in">Forward</span>(target_latitude, target_longitude, target_height, x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换后的局部坐标</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local Cartesian coordinates: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上述步骤，你可以在你的C++项目中轻松使用GeographicLib进行地理坐标转换。GeographicLib提供了简单且高效的方法来处理经纬度与局部直角坐标系之间的转换，为地理信息处理提供了便利。在实际应用中，可以根据需要进行更复杂的坐标转换和计算，满足不同场景下的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用GeographicLib在C-中进行地理坐标转换&quot;&gt;&lt;a href=&quot;#使用GeographicLib在C-中进行地理坐标转换&quot; class=&quot;headerlink&quot; title=&quot;使用GeographicLib在C++中进行地理坐标转换&quot;&gt;&lt;/a&gt;使用Ge</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>理解矩阵内积与矩阵乘法的区别及其应用</title>
    <link href="https://www.clang.asia/2024/07/29/%E7%90%86%E8%A7%A3%E7%9F%A9%E9%98%B5%E5%86%85%E7%A7%AF%E4%B8%8E%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://www.clang.asia/2024/07/29/%E7%90%86%E8%A7%A3%E7%9F%A9%E9%98%B5%E5%86%85%E7%A7%AF%E4%B8%8E%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2024-07-29T09:27:17.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<p>在数据科学、机器学习、计算机图形学和图像处理等领域，矩阵运算是非常基础且重要的操作。然而，矩阵内积和矩阵乘法这两种看似相似的操作却有着不同的计算方式和应用场景。本文将详细解释它们的区别及各自的用途。</p><h3 id="矩阵内积（逐元素乘积）"><a href="#矩阵内积（逐元素乘积）" class="headerlink" title="矩阵内积（逐元素乘积）"></a>矩阵内积（逐元素乘积）</h3><p>矩阵内积，或逐元素乘积，是指两个相同尺寸的矩阵对应位置元素的逐一相乘。这种运算在 numpy 中可以使用 <code>*</code> 运算符或者 <code>np.multiply</code> 函数来实现。</p><p>例如，给定两个矩阵 A 和 B：<br>$$<br>A &#x3D; \begin{bmatrix} 1 &amp; 2 \ 3 &amp; 4 \end{bmatrix}<br>B &#x3D; \begin{bmatrix} 5 &amp; 6 \ 7 &amp; 8 \end{bmatrix}<br>$$</p><p>它们的逐元素乘积为：<br>$$<br>A * B &#x3D; \begin{bmatrix} 1 \cdot 5 &amp; 2 \cdot 6 \ 3 \cdot 7 &amp; 4 \cdot 8 \end{bmatrix} &#x3D; \begin{bmatrix} 5 &amp; 12 \ 21 &amp; 32 \end{bmatrix}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐元素乘积</span></span><br><span class="line">result = A * B</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [[ 5 12]</span></span><br><span class="line"><span class="comment">#  [21 32]]</span></span><br></pre></td></tr></table></figure><h3 id="矩阵内积的用途"><a href="#矩阵内积的用途" class="headerlink" title="矩阵内积的用途"></a>矩阵内积的用途</h3><ol><li><p><strong>图像处理</strong>：</p><ul><li><strong>滤波</strong>：在卷积操作中，滤波器（或核）与图像的一个区域进行逐元素相乘，然后求和。</li><li><strong>图像增强或衰减</strong>：通过逐元素乘以一个比例因子矩阵。</li></ul></li><li><p><strong>统计计算</strong>：</p><ul><li><strong>加权平均值</strong>：通过逐元素乘积将权重应用于数据矩阵。</li></ul></li><li><p><strong>科学计算和数值分析</strong>：</p><ul><li><strong>离散模型计算</strong>：逐元素乘积用于计算两组数据的交互影响，例如离散反应速率计算。</li></ul></li></ol><h3 id="矩阵乘法（矩阵积）"><a href="#矩阵乘法（矩阵积）" class="headerlink" title="矩阵乘法（矩阵积）"></a>矩阵乘法（矩阵积）</h3><p>矩阵乘法是线性代数中的基本操作，遵循特定的规则。假设矩阵 A 的维度是 m×n，矩阵 B 的维度是 n×p，则它们的乘积 C 的维度是 m×p。C 的每个元素是 A 的行向量和 B 的列向量的点积。</p><p>例如，给定矩阵 A 和 B：<br>$$<br>A &#x3D; \begin{bmatrix} 1 &amp; 2 \ 3 &amp; 4 \end{bmatrix}<br>B &#x3D; \begin{bmatrix} 5 &amp; 6 \ 7 &amp; 8 \end{bmatrix}<br>$$</p><p>它们的矩阵乘积为：<br>$$<br>C &#x3D; A \cdot B &#x3D; \begin{bmatrix} 1 \cdot 5 + 2 \cdot 7 &amp; 1 \cdot 6 + 2 \cdot 8 \ 3 \cdot 5 + 4 \cdot 7 &amp; 3 \cdot 6 + 4 \cdot 8 \end{bmatrix} &#x3D; \begin{bmatrix} 19 &amp; 22 \ 43 &amp; 50 \end{bmatrix}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘积</span></span><br><span class="line">result = np.dot(A, B)</span><br><span class="line"><span class="comment"># 或者使用 @ 运算符（Python 3.5 及以上）</span></span><br><span class="line">result = A @ B</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br></pre></td></tr></table></figure><h3 id="矩阵乘法的用途"><a href="#矩阵乘法的用途" class="headerlink" title="矩阵乘法的用途"></a>矩阵乘法的用途</h3><ol><li><p><strong>线性代数</strong>：</p><ul><li><strong>线性变换</strong>：如旋转、缩放、平移等。</li><li><strong>线性方程组</strong>：表示和求解线性方程组。</li></ul></li><li><p><strong>计算机图形学</strong>：</p><ul><li><strong>3D 变换和投影</strong>：通过矩阵乘法将 3D 点变换到不同的坐标系。</li></ul></li><li><p><strong>机器学习和数据科学</strong>：</p><ul><li><strong>神经网络</strong>：权重矩阵与输入向量的乘法。</li><li><strong>数据降维</strong>：主成分分析（PCA）、奇异值分解（SVD）等矩阵分解技术。</li></ul></li><li><p><strong>物理模拟</strong>：</p><ul><li><strong>动态系统状态更新</strong>：通过状态转移矩阵模拟系统的演化。</li></ul></li></ol><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol><li><p><strong>计算方式</strong>：</p><ul><li><strong>逐元素乘积（内积）</strong>：对应位置的元素相乘。</li><li><strong>矩阵乘法</strong>：行和列的点积，遵循线性代数规则。</li></ul></li><li><p><strong>尺寸要求</strong>：</p><ul><li><strong>逐元素乘积（内积）</strong>：两个矩阵必须具有相同的尺寸。</li><li><strong>矩阵乘法</strong>：第一个矩阵的列数必须等于第二个矩阵的行数。</li></ul></li><li><p><strong>结果矩阵的尺寸</strong>：</p><ul><li><strong>逐元素乘积（内积）</strong>：结果矩阵的尺寸与操作数矩阵相同。</li><li><strong>矩阵乘法</strong>：结果矩阵的尺寸为第一个矩阵的行数和第二个矩阵的列数。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解矩阵内积和矩阵乘法的区别及各自的用途，对于数据科学、机器学习、图像处理和计算机图形学等领域的工作至关重要。选择适合的矩阵运算方法可以有效地解决问题，提高计算效率和结果的准确性。希望本文能帮助你更好地理解和应用这两种重要的矩阵运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在数据科学、机器学习、计算机图形学和图像处理等领域，矩阵运算是非常基础且重要的操作。然而，矩阵内积和矩阵乘法这两种看似相似的操作却有着不同的计算方式和应用场景。本文将详细解释它们的区别及各自的用途。&lt;/p&gt;
&lt;h3 id=&quot;矩阵内积（逐元素乘积）&quot;&gt;&lt;a href=&quot;#矩阵</summary>
      
    
    
    
    <category term="AI" scheme="https://www.clang.asia/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.clang.asia/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>跨机器ROS服务调用：在不同包名下实现分布式服务端和客户端节点</title>
    <link href="https://www.clang.asia/2024/07/23/%E8%B7%A8%E6%9C%BA%E5%99%A8ROS%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%EF%BC%9A%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%8C%85%E5%90%8D%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8A%82%E7%82%B9/"/>
    <id>https://www.clang.asia/2024/07/23/%E8%B7%A8%E6%9C%BA%E5%99%A8ROS%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%EF%BC%9A%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%8C%85%E5%90%8D%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8A%82%E7%82%B9/</id>
    <published>2024-07-23T11:02:15.000Z</published>
    <updated>2025-10-28T11:39:25.136Z</updated>
    
    <content type="html"><![CDATA[<p>好的，我们将分别为服务端和客户端使用不同的包名，例如服务端使用<code>robot_server_package</code>，客户端使用<code>robot_client_package</code>。</p><h3 id="一、服务端节点配置（robot-server）"><a href="#一、服务端节点配置（robot-server）" class="headerlink" title="一、服务端节点配置（robot_server）"></a>一、服务端节点配置（robot_server）</h3><h4 id="创建包和定义服务类型"><a href="#创建包和定义服务类型" class="headerlink" title="创建包和定义服务类型"></a>创建包和定义服务类型</h4><ol><li><p>创建一个名为<code>robot_server_package</code>的包，并在<code>srv</code>目录下创建一个名为<code>AddTwoInts.srv</code>的文件：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure></li><li><p>确保在<code>CMakeLists.txt</code>和<code>package.xml</code>中正确配置，以便生成服务代码。</p><p><code>CMakeLists.txt</code>：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(robot_server_package)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  AddTwoInts.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS rospy std_msgs message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>package.xml</code>：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>robot_server_package<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The robot_server_package<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;your_email@example.com&quot;</span>&gt;</span>Your Name<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>catkin_make</code>生成消息和服务代码。</p></li></ol><h4 id="编写服务端节点"><a href="#编写服务端节点" class="headerlink" title="编写服务端节点"></a>编写服务端节点</h4><p>编写服务端节点<code>add_two_ints_server.py</code>，并将其放在<code>robot_server_package/scripts</code>目录下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> robot_server_package.srv <span class="keyword">import</span> AddTwoInts, AddTwoIntsResponse</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_add_two_ints</span>(<span class="params">req</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Returning [%s + %s = %s]&quot;</span> % (req.a, req.b, (req.a + req.b)))</span><br><span class="line">    <span class="keyword">return</span> AddTwoIntsResponse(req.a + req.b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_server</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;add_two_ints_server&#x27;</span>)</span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Ready to add two ints.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    add_two_ints_server()</span><br></pre></td></tr></table></figure><h3 id="二、客户端节点配置（robot-client）"><a href="#二、客户端节点配置（robot-client）" class="headerlink" title="二、客户端节点配置（robot_client）"></a>二、客户端节点配置（robot_client）</h3><h4 id="创建包和定义服务类型-1"><a href="#创建包和定义服务类型-1" class="headerlink" title="创建包和定义服务类型"></a>创建包和定义服务类型</h4><ol><li><p>创建一个名为<code>robot_client_package</code>的包，并在<code>srv</code>目录下创建一个名为<code>AddTwoInts.srv</code>的文件，与服务端的服务类型相同：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure></li><li><p>确保在<code>CMakeLists.txt</code>和<code>package.xml</code>中正确配置，以便生成服务代码。</p><p><code>CMakeLists.txt</code>：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(robot_client_package)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  AddTwoInts.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS rospy std_msgs message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>package.xml</code>：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>robot_client_package<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The robot_client_package<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;your_email@example.com&quot;</span>&gt;</span>Your Name<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>catkin_make</code>生成消息和服务代码。</p></li></ol><h4 id="编写客户端节点"><a href="#编写客户端节点" class="headerlink" title="编写客户端节点"></a>编写客户端节点</h4><p>编写客户端节点<code>add_two_ints_client.py</code>，并将其放在<code>robot_client_package/scripts</code>目录下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> robot_client_package.srv <span class="keyword">import</span> AddTwoInts</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;add_two_ints&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add_two_ints = rospy.ServiceProxy(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts)</span><br><span class="line">        resp = add_two_ints(x, y)</span><br><span class="line">        <span class="keyword">return</span> resp.<span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException <span class="keyword">as</span> e:</span><br><span class="line">        rospy.logerr(<span class="string">&quot;Service call failed: %s&quot;</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: %s [x y]&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Requesting %s+%s&quot;</span> % (x, y))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span> % (x, y, add_two_ints_client(x, y)))</span><br></pre></td></tr></table></figure><h3 id="三、运行服务和客户端"><a href="#三、运行服务和客户端" class="headerlink" title="三、运行服务和客户端"></a>三、运行服务和客户端</h3><ol><li><strong>在两台机器上设置ROS环境</strong></li></ol><p>确保<code>/etc/hosts</code>文件包含彼此的IP地址和主机名。例如，在<code>robot_server</code>和<code>robot_client</code>机器上的<code>/etc/hosts</code>文件应该包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2 robot_server</span><br><span class="line">192.168.1.3 robot_client</span><br></pre></td></tr></table></figure><p>在<code>robot_server</code>上设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ROS_MASTER_URI=http://robot_server:11311</span><br><span class="line"><span class="built_in">export</span> ROS_IP=robot_server</span><br></pre></td></tr></table></figure><p>在<code>robot_client</code>上设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ROS_MASTER_URI=http://robot_server:11311</span><br><span class="line"><span class="built_in">export</span> ROS_IP=robot_client</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动ROS master</strong></li></ol><p>在<code>robot_server</code>上运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>3.<strong>在<code>robot_server</code>上运行服务端节点</strong></p><p>确保脚本是可执行的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ~/catkin_ws/src/robot_server_package/scripts/add_two_ints_server.py</span><br></pre></td></tr></table></figure><p>运行服务端节点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun robot_server_package add_two_ints_server.py</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>在<code>robot_client</code>上运行客户端节点</strong></li></ol><p>确保脚本是可执行的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ~/catkin_ws/src/robot_client_package/scripts/add_two_ints_client.py</span><br></pre></td></tr></table></figure><p>运行客户端节点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun robot_client_package add_two_ints_client.py 2 3</span><br></pre></td></tr></table></figure><p>如果配置正确，你应该会在<code>robot_server</code>上看到服务端处理请求的输出，并在<code>robot_client</code>上看到客户端请求的结果。</p><p>这样，你就可以在不同的机器上运行ROS节点，并调用共享的服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好的，我们将分别为服务端和客户端使用不同的包名，例如服务端使用&lt;code&gt;robot_server_package&lt;/code&gt;，客户端使用&lt;code&gt;robot_client_package&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;一、服务端节点配置（robot-serv</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu上创建和启用交换文件的简单步骤</title>
    <link href="https://www.clang.asia/2024/07/16/%E5%9C%A8Ubuntu%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E7%94%A8%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/"/>
    <id>https://www.clang.asia/2024/07/16/%E5%9C%A8Ubuntu%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E7%94%A8%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/</id>
    <published>2024-07-16T02:00:05.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统中，交换空间是一种将内存数据临时存储在磁盘上的机制，用于缓解内存不足的情况。本文将介绍如何在Ubuntu系统上创建和启用一个12GB的交换文件。这是一种不需要重新分区的简单方法。</p><h3 id="为什么使用交换文件？"><a href="#为什么使用交换文件？" class="headerlink" title="为什么使用交换文件？"></a>为什么使用交换文件？</h3><p>交换文件与交换分区功能相同，但更加灵活。你可以在不重新分区的情况下轻松调整交换空间的大小。以下是创建和启用交换文件的详细步骤。</p><h3 id="步骤-1：创建交换文件"><a href="#步骤-1：创建交换文件" class="headerlink" title="步骤 1：创建交换文件"></a>步骤 1：创建交换文件</h3><p>首先，我们需要在文件系统上创建一个12GB的交换文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fallocate -l 12G /swapfile</span><br></pre></td></tr></table></figure><p>如果 <code>fallocate</code> 命令不可用，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=12288</span><br></pre></td></tr></table></figure><h3 id="步骤-2：设置正确的权限"><a href="#步骤-2：设置正确的权限" class="headerlink" title="步骤 2：设置正确的权限"></a>步骤 2：设置正确的权限</h3><p>为了确保系统安全，我们需要将交换文件的权限设置为只有root用户可以读取和写入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-3：将文件格式化为交换空间"><a href="#步骤-3：将文件格式化为交换空间" class="headerlink" title="步骤 3：将文件格式化为交换空间"></a>步骤 3：将文件格式化为交换空间</h3><p>现在，我们需要将这个文件格式化为交换空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkswap /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-4：启用交换文件"><a href="#步骤-4：启用交换文件" class="headerlink" title="步骤 4：启用交换文件"></a>步骤 4：启用交换文件</h3><p>接下来，启用这个交换文件，使其立即生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-5：验证交换文件"><a href="#步骤-5：验证交换文件" class="headerlink" title="步骤 5：验证交换文件"></a>步骤 5：验证交换文件</h3><p>你可以使用以下命令验证交换文件是否已成功启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon --show</span><br></pre></td></tr></table></figure><p>你应该会看到类似于以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME      TYPE  SIZE USED PRIO</span><br><span class="line">/swapfile file  12G  0B   -2</span><br></pre></td></tr></table></figure><h3 id="步骤-6：永久启用交换文件"><a href="#步骤-6：永久启用交换文件" class="headerlink" title="步骤 6：永久启用交换文件"></a>步骤 6：永久启用交换文件</h3><p>为了确保交换文件在系统启动时自动启用，我们需要编辑 <code>/etc/fstab</code> 文件。添加以下内容到文件末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure><h3 id="步骤-7：调整-swappiness-参数（可选）"><a href="#步骤-7：调整-swappiness-参数（可选）" class="headerlink" title="步骤 7：调整 swappiness 参数（可选）"></a>步骤 7：调整 <code>swappiness</code> 参数（可选）</h3><p><code>swappiness</code> 参数决定了系统将多频繁地使用交换空间。默认值是60，范围是0到100。较低的值表示系统更倾向于使用物理内存，而不是交换空间。你可以将 <code>swappiness</code> 设置为10，以优化性能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sysctl vm.swappiness=10</span><br></pre></td></tr></table></figure><p>为了使这个设置永久生效，编辑 <code>/etc/sysctl.conf</code> 文件，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><h3 id="检查设置"><a href="#检查设置" class="headerlink" title="检查设置"></a>检查设置</h3><p>最后，确认交换分区和 <code>swappiness</code> 设置是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/vm/swappiness</span><br><span class="line"><span class="built_in">sudo</span> swapon --show</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过以上简单步骤，你已经成功在Ubuntu系统上创建并启用了一个12GB的交换文件。这种方法不仅简单，而且灵活，适用于各种Linux系统。如果你有任何问题或需要进一步的帮助，请随时留言！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux系统中，交换空间是一种将内存数据临时存储在磁盘上的机制，用于缓解内存不足的情况。本文将介绍如何在Ubuntu系统上创建和启用一个12GB的交换文件。这是一种不需要重新分区的简单方法。&lt;/p&gt;
&lt;h3 id=&quot;为什么使用交换文件？&quot;&gt;&lt;a href=&quot;#为什么使用</summary>
      
    
    
    
    <category term="运维" scheme="https://www.clang.asia/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://www.clang.asia/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数据预处理详解：标准化、填充缺失值及编码离散特征</title>
    <link href="https://www.clang.asia/2024/06/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%8F%8A%E7%BC%96%E7%A0%81%E7%A6%BB%E6%95%A3%E7%89%B9%E5%BE%81/"/>
    <id>https://www.clang.asia/2024/06/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%8F%8A%E7%BC%96%E7%A0%81%E7%A6%BB%E6%95%A3%E7%89%B9%E5%BE%81/</id>
    <published>2024-06-29T09:27:17.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习建模过程中，数据预处理是至关重要的一步。本文将通过具体示例，详细解释数据预处理的关键步骤，包括标准化数值特征、填充缺失值以及编码离散特征。我们将使用一个简单的训练和测试数据集来说明这些步骤。</p><h3 id="示例数据集"><a href="#示例数据集" class="headerlink" title="示例数据集"></a>示例数据集</h3><h4 id="训练数据-train-data"><a href="#训练数据-train-data" class="headerlink" title="训练数据 (train_data)"></a>训练数据 (<code>train_data</code>)</h4><table><thead><tr><th>Id</th><th>Feature1</th><th>Feature2</th><th>Feature3</th><th>Label</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>5.0</td><td>A</td><td>100</td></tr><tr><td>2</td><td>20</td><td>6.5</td><td>B</td><td>200</td></tr><tr><td>3</td><td>30</td><td>NaN</td><td>A</td><td>300</td></tr></tbody></table><h4 id="测试数据-test-data"><a href="#测试数据-test-data" class="headerlink" title="测试数据 (test_data)"></a>测试数据 (<code>test_data</code>)</h4><table><thead><tr><th>Id</th><th>Feature1</th><th>Feature2</th><th>Feature3</th></tr></thead><tbody><tr><td>4</td><td>25</td><td>5.5</td><td>B</td></tr><tr><td>5</td><td>35</td><td>7.0</td><td>NaN</td></tr></tbody></table><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h3><h4 id="1-合并所有特征以进行预处理"><a href="#1-合并所有特征以进行预处理" class="headerlink" title="1. 合并所有特征以进行预处理"></a>1. 合并所有特征以进行预处理</h4><p>首先，将训练和测试数据集的特征（不包括标签列<code>Label</code>）合并，以便对所有特征进行统一的预处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><p><strong>合并后的结果：</strong></p><table><thead><tr><th>Feature1</th><th>Feature2</th><th>Feature3</th></tr></thead><tbody><tr><td>10</td><td>5.0</td><td>A</td></tr><tr><td>20</td><td>6.5</td><td>B</td></tr><tr><td>30</td><td>NaN</td><td>A</td></tr><tr><td>25</td><td>5.5</td><td>B</td></tr><tr><td>35</td><td>7.0</td><td>NaN</td></tr></tbody></table><h4 id="2-标准化数值特征"><a href="#2-标准化数值特征" class="headerlink" title="2. 标准化数值特征"></a>2. 标准化数值特征</h4><p>确定数值型特征的列，然后对这些特征进行标准化处理，使每个数值特征的均值为0，标准差为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / x.std())</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Feature1</code> 和 <code>Feature2</code> 是数值型特征。首先计算它们的均值和标准差：</p><ul><li><code>Feature1</code>的均值 &#x3D; (10 + 20 + 30 + 25 + 35) &#x2F; 5 &#x3D; 24</li><li><code>Feature1</code>的标准差 ≈ 9.57</li><li><code>Feature2</code>的均值 &#x3D; (5.0 + 6.5 + 5.5 + 7.0) &#x2F; 4 &#x3D; 6.0</li><li><code>Feature2</code>的标准差 ≈ 0.79</li></ul><p>标准化后的结果：</p><table><thead><tr><th>Feature1</th><th>Feature2</th><th>Feature3</th></tr></thead><tbody><tr><td>-1.46</td><td>-1.27</td><td>A</td></tr><tr><td>-0.42</td><td>0.63</td><td>B</td></tr><tr><td>0.63</td><td>NaN</td><td>A</td></tr><tr><td>0.10</td><td>-0.63</td><td>B</td></tr><tr><td>1.15</td><td>1.27</td><td>NaN</td></tr></tbody></table><h4 id="3-填充缺失值为0"><a href="#3-填充缺失值为0" class="headerlink" title="3. 填充缺失值为0"></a>3. 填充缺失值为0</h4><p>将数值型特征中的缺失值（NaN）填充为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>填充缺失值后的结果：</p><table><thead><tr><th>Feature1</th><th>Feature2</th><th>Feature3</th></tr></thead><tbody><tr><td>-1.46</td><td>-1.27</td><td>A</td></tr><tr><td>-0.42</td><td>0.63</td><td>B</td></tr><tr><td>0.63</td><td>0.00</td><td>A</td></tr><tr><td>0.10</td><td>-0.63</td><td>B</td></tr><tr><td>1.15</td><td>1.27</td><td>NaN</td></tr></tbody></table><h4 id="4-处理离散数值特征"><a href="#4-处理离散数值特征" class="headerlink" title="4. 处理离散数值特征"></a>4. 处理离散数值特征</h4><p>将离散特征（分类特征）进行独热编码（one-hot encoding），包括缺失值（dummy_na&#x3D;True）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>编码后的结果：</p><table><thead><tr><th>Feature1</th><th>Feature2</th><th>Feature3_A</th><th>Feature3_B</th><th>Feature3_nan</th></tr></thead><tbody><tr><td>-1.46</td><td>-1.27</td><td>1</td><td>0</td><td>0</td></tr><tr><td>-0.42</td><td>0.63</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0.63</td><td>0.00</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0.10</td><td>-0.63</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1.15</td><td>1.27</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><h4 id="5-确保所有特征都是数值类型"><a href="#5-确保所有特征都是数值类型" class="headerlink" title="5. 确保所有特征都是数值类型"></a>5. 确保所有特征都是数值类型</h4><p>确保所有特征的数据类型都是 <code>float32</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = all_features.astype(np.float32)</span><br></pre></td></tr></table></figure><p>最终结果是一个完全由数值型特征组成的DataFrame，并且所有特征都经过标准化和缺失值处理，准备好用于后续的模型训练和预测：</p><p><strong>最终结果：</strong></p><table><thead><tr><th>Feature1</th><th>Feature2</th><th>Feature3_A</th><th>Feature3_B</th><th>Feature3_nan</th></tr></thead><tbody><tr><td>-1.46</td><td>-1.27</td><td>1.0</td><td>0.0</td><td>0.0</td></tr><tr><td>-0.42</td><td>0.63</td><td>0.0</td><td>1.0</td><td>0.0</td></tr><tr><td>0.63</td><td>0.00</td><td>1.0</td><td>0.0</td><td>0.0</td></tr><tr><td>0.10</td><td>-0.63</td><td>0.0</td><td>1.0</td><td>0.0</td></tr><tr><td>1.15</td><td>1.27</td><td>0.0</td><td>0.0</td><td>1.0</td></tr></tbody></table><p>通过这些步骤，我们成功地对训练和测试数据集的特征进行了标准化、缺失值处理和独热编码，使其准备好用于后续的模型训练和预测。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在机器学习建模过程中，数据预处理是至关重要的一步。本文将通过具体示例，详细解释数据预处理的关键步骤，包括标准化数值特征、填充缺失值以及编码离散特征。我们将使用一个简单的训练和测试数据集来说明这些步骤。&lt;/p&gt;
&lt;h3 id=&quot;示例数据集&quot;&gt;&lt;a href=&quot;#示例数据集&quot; </summary>
      
    
    
    
    <category term="AI" scheme="https://www.clang.asia/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.clang.asia/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>使用 PyTorch 和 Pandas 进行 Kaggle 房价预测</title>
    <link href="https://www.clang.asia/2024/06/28/%E4%BD%BF%E7%94%A8%20PyTorch%20%E5%92%8C%20Pandas%20%E8%BF%9B%E8%A1%8C%20Kaggle%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/"/>
    <id>https://www.clang.asia/2024/06/28/%E4%BD%BF%E7%94%A8%20PyTorch%20%E5%92%8C%20Pandas%20%E8%BF%9B%E8%A1%8C%20Kaggle%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</id>
    <published>2024-06-28T22:49:45.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇博文中，我们将探索如何使用 PyTorch 和 Pandas 库，构建一个用于 Kaggle 房价预测的模型。我们将详细讨论数据加载、预处理、模型构建、训练、验证及最终预测的全过程。</p><h2 id="1、环境设置"><a href="#1、环境设置" class="headerlink" title="1、环境设置"></a>1、环境设置</h2><p>我们首先需要导入所需的库，包括用于数据处理的 <code>pandas</code> 和 <code>numpy</code>，以及用于深度学习的 <code>torch</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><h2 id="2、数据下载"><a href="#2、数据下载" class="headerlink" title="2、数据下载"></a>2、数据下载</h2><p>为了下载数据，我们需要定义一个下载函数，并在其中实现数据缓存机制以避免重复下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存DATA_HUB字典以便下载数据</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存下载函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name, cache_dir=os.path.join(<span class="params"><span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname):</span><br><span class="line">        sha1 = hashlib.sha1()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data)</span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 命中缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname</span><br></pre></td></tr></table></figure><p>接下来，我们在 <code>DATA_HUB</code> 中注册 Kaggle 房价预测的训练和测试数据集，并下载这些数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在DATA_HUB中注册Kaggle房价预测的训练和测试数据集</span></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并加载数据</span></span><br><span class="line">train_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_train&#x27;</span>))</span><br><span class="line">test_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_test&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="3、数据预处理"><a href="#3、数据预处理" class="headerlink" title="3、数据预处理"></a>3、数据预处理</h2><p>我们首先查看数据集的形状和部分内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据集的形状和部分内容</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(test_data.shape)</span><br><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>然后，我们合并所有特征以进行统一预处理，并标准化数值特征，填充缺失值为0，处理离散数值特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并所有特征以进行预处理</span></span><br><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化数值特征</span></span><br><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 填充缺失值为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理离散数值特征（dummy_na=True包括缺失值）</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有特征都是数值类型</span></span><br><span class="line">all_features = all_features.astype(np.float32)</span><br></pre></td></tr></table></figure><p>将数据转换为 tensor 格式，以便 PyTorch 使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据转换为tensor格式</span></span><br><span class="line">n_train = train_data.shape[<span class="number">0</span>]</span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)</span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line">train_labels = torch.tensor(train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br></pre></td></tr></table></figure><h2 id="4、模型构建"><a href="#4、模型构建" class="headerlink" title="4、模型构建"></a>4、模型构建</h2><p>我们定义一个简单的线性回归模型，并设置损失函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义损失函数和获取网络结构</span></span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><h2 id="5、训练和验证"><a href="#5、训练和验证" class="headerlink" title="5、训练和验证"></a>5、训练和验证</h2><p>为了更好地评估模型，我们定义了 K 折交叉验证和训练函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义log_rmse函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_rmse</span>(<span class="params">net, features, labels</span>):</span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels)))</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size</span>):</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels), batch_size)</span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, weight_decay=weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取k折交叉验证的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>)</span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义k折交叉验证函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, learning_rate, weight_decay, batch_size</span>):</span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate, weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>)), [train_ls, valid_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>，训练log rmse<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>, 验证log rmse<span class="subst">&#123;<span class="built_in">float</span>(valid_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h2 id="6、训练模型并生成预测结果"><a href="#6、训练模型并生成预测结果" class="headerlink" title="6、训练模型并生成预测结果"></a>6、训练模型并生成预测结果</h2><p>我们定义了最终的训练和预测函数，并训练模型生成预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义超参数并进行k折交叉验证</span></span><br><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, 平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最终的训练和预测函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_pred</span>(<span class="params">train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size</span>):</span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>, num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.plot(np.arange(<span class="number">1</span>, num_epochs + <span class="number">1</span>), [train_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;log rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型并生成预测结果</span></span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><p>通过上述步骤，我们成功地使用 PyTorch 和 Pandas 实现了一个简单的线性回归模型，用于 Kaggle 房价预测任务。这篇博文涵盖了数据下载、预处理、模型构建、训练、验证及预测的全过程，为类似任务提供了一个完整的参考。</p><h2 id="7、完整代码"><a href="#7、完整代码" class="headerlink" title="7、完整代码"></a>7、完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存DATA_HUB字典以便下载数据</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存下载函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name, cache_dir=os.path.join(<span class="params"><span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname):</span><br><span class="line">        sha1 = hashlib.sha1()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data)</span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 命中缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在DATA_HUB中注册Kaggle房价预测的训练和测试数据集</span></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并加载数据</span></span><br><span class="line">train_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_train&#x27;</span>))</span><br><span class="line">test_data = pd.read_csv(download(<span class="string">&#x27;kaggle_house_test&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据集的形状和部分内容</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(test_data.shape)</span><br><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并所有特征以进行预处理</span></span><br><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化数值特征</span></span><br><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 填充缺失值为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理离散数值特征（dummy_na=True包括缺失值）</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有特征都是数值类型</span></span><br><span class="line">all_features = all_features.astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据转换为tensor格式</span></span><br><span class="line">n_train = train_data.shape[<span class="number">0</span>]</span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)</span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line">train_labels = torch.tensor(train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和获取网络结构</span></span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义log_rmse函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_rmse</span>(<span class="params">net, features, labels</span>):</span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels)))</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size</span>):</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels), batch_size)</span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, weight_decay=weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取k折交叉验证的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>)</span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义k折交叉验证函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, learning_rate, weight_decay, batch_size</span>):</span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate, weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>)), [train_ls, valid_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>，训练log rmse<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>, 验证log rmse<span class="subst">&#123;<span class="built_in">float</span>(valid_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义超参数并进行k折交叉验证</span></span><br><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, 平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最终的训练和预测函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_pred</span>(<span class="params">train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size</span>):</span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>, num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.plot(np.arange(<span class="number">1</span>, num_epochs + <span class="number">1</span>), [train_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;log rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型并生成预测结果</span></span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本篇博文中，我们将探索如何使用 PyTorch 和 Pandas 库，构建一个用于 Kaggle 房价预测的模型。我们将详细讨论数据加载、预处理、模型构建、训练、验证及最终预测的全过程。&lt;/p&gt;
&lt;h2 id=&quot;1、环境设置&quot;&gt;&lt;a href=&quot;#1、环境设置&quot; clas</summary>
      
    
    
    
    <category term="AI" scheme="https://www.clang.asia/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.clang.asia/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>如何在不同电脑之间导出和导入 Docker 镜像</title>
    <link href="https://www.clang.asia/2024/06/19/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B9%8B%E9%97%B4%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%20Docker%20%E9%95%9C%E5%83%8F/"/>
    <id>https://www.clang.asia/2024/06/19/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B9%8B%E9%97%B4%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%20Docker%20%E9%95%9C%E5%83%8F/</id>
    <published>2024-06-19T02:00:05.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何在不同电脑之间导出和导入-Docker-镜像"><a href="#如何在不同电脑之间导出和导入-Docker-镜像" class="headerlink" title="如何在不同电脑之间导出和导入 Docker 镜像"></a>如何在不同电脑之间导出和导入 Docker 镜像</h2><p>在开发和部署过程中，你可能会遇到需要将 Docker 镜像从一台电脑导出并导入到另一台电脑的情况。无论是为了分享镜像，还是为了在不同环境中进行测试，Docker 都提供了方便的工具来实现这一需求。本文将详细介绍如何使用 <code>docker save</code> 和 <code>docker load</code> 命令将 Docker 镜像从一台电脑传输到另一台电脑。</p><h3 id="步骤-1：导出镜像"><a href="#步骤-1：导出镜像" class="headerlink" title="步骤 1：导出镜像"></a>步骤 1：导出镜像</h3><p>首先，在源电脑上使用 <code>docker save</code> 命令将 Docker 镜像保存为一个 tar 文件。假设你要导出的镜像名为 <code>foxy_noetic_ubuntu20.04:v1</code>，你可以运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o foxy_noetic_ubuntu20.04_v1.tar foxy_noetic_ubuntu20.04:v1</span><br></pre></td></tr></table></figure><p>这条命令会创建一个名为 <code>foxy_noetic_ubuntu20.04_v1.tar</code> 的文件，该文件包含了 <code>foxy_noetic_ubuntu20.04:v1</code> 镜像的所有内容。</p><h3 id="步骤-2：传输镜像文件"><a href="#步骤-2：传输镜像文件" class="headerlink" title="步骤 2：传输镜像文件"></a>步骤 2：传输镜像文件</h3><p>接下来，需要将生成的 tar 文件从源电脑传输到目标电脑。你可以使用各种工具来实现这一点，例如 <code>scp</code>、<code>rsync</code>、USB 设备等。</p><p>以下是使用 <code>scp</code> 命令传输文件的示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp foxy_noetic_ubuntu20.04_v1.tar user@target-computer:/path/to/destination</span><br></pre></td></tr></table></figure><p>在此命令中，将 <code>user@target-computer</code> 替换为目标电脑的用户名和地址，并将 <code>/path/to/destination</code> 替换为目标路径。</p><h3 id="步骤-3：导入镜像"><a href="#步骤-3：导入镜像" class="headerlink" title="步骤 3：导入镜像"></a>步骤 3：导入镜像</h3><p>在目标电脑上，使用 <code>docker load</code> 命令从 tar 文件中加载 Docker 镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/destination/foxy_noetic_ubuntu20.04_v1.tar</span><br></pre></td></tr></table></figure><p>这条命令会从指定的 tar 文件中加载镜像，并将其添加到本地 Docker 镜像库中。</p><h3 id="步骤-4：验证镜像"><a href="#步骤-4：验证镜像" class="headerlink" title="步骤 4：验证镜像"></a>步骤 4：验证镜像</h3><p>导入完成后，你可以使用 <code>docker images</code> 命令来验证镜像是否成功导入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>你应该能够看到 <code>foxy_noetic_ubuntu20.04:v1</code> 镜像在列表中。</p><h3 id="完整操作示例"><a href="#完整操作示例" class="headerlink" title="完整操作示例"></a>完整操作示例</h3><p>以下是完整的操作步骤：</p><p><strong>在源电脑上：</strong></p><ol><li><p>将镜像保存为 tar 文件：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o foxy_noetic_ubuntu20.04_v1.tar foxy_noetic_ubuntu20.04:v1</span><br></pre></td></tr></table></figure></li><li><p>将 tar 文件传输到目标电脑：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp foxy_noetic_ubuntu20.04_v1.tar user@target-computer:/path/to/destination</span><br></pre></td></tr></table></figure></li></ol><p><strong>在目标电脑上：</strong></p><ol><li><p>从 tar 文件中加载镜像：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/destination/foxy_noetic_ubuntu20.04_v1.tar</span><br></pre></td></tr></table></figure></li><li><p>验证镜像是否成功导入：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过以上步骤，你可以轻松地将 Docker 镜像从一台电脑导出并导入到另一台电脑。这对于在不同环境中测试应用程序或共享镜像非常有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何在不同电脑之间导出和导入-Docker-镜像&quot;&gt;&lt;a href=&quot;#如何在不同电脑之间导出和导入-Docker-镜像&quot; class=&quot;headerlink&quot; title=&quot;如何在不同电脑之间导出和导入 Docker 镜像&quot;&gt;&lt;/a&gt;如何在不同电脑之间导出和导入</summary>
      
    
    
    
    <category term="运维" scheme="https://www.clang.asia/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://www.clang.asia/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu20.04安装ros noetic</title>
    <link href="https://www.clang.asia/2024/06/15/ubuntu20.04%E5%AE%89%E8%A3%85ros%20noetic/"/>
    <id>https://www.clang.asia/2024/06/15/ubuntu20.04%E5%AE%89%E8%A3%85ros%20noetic/</id>
    <published>2024-06-15T09:56:17.000Z</published>
    <updated>2025-10-28T11:39:25.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装ROS-neotic步骤"><a href="#一、安装ROS-neotic步骤" class="headerlink" title="一、安装ROS neotic步骤"></a>一、安装ROS neotic步骤</h2><h3 id="第一步：换源（在软件和更新里面）"><a href="#第一步：换源（在软件和更新里面）" class="headerlink" title="第一步：换源（在软件和更新里面）"></a>第一步：换源（在软件和更新里面）</h3><p>这一步非常重要，决定着后面安装ROS能否成功的关键一步。<br>这里，我选择了中科大（<a href="https://mirrors.ustc.edu.cn/ubuntu/%EF%BC%89%E3%80%82">https://mirrors.ustc.edu.cn/ubuntu/）。</a></p><h3 id="第二步：添加ROS软件源"><a href="#第二步：添加ROS软件源" class="headerlink" title="第二步：添加ROS软件源"></a>第二步：添加ROS软件源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><h3 id="第三步：添加密钥"><a href="#第三步：添加密钥" class="headerlink" title="第三步：添加密钥"></a>第三步：添加密钥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h3 id="第四步：更新软件源"><a href="#第四步：更新软件源" class="headerlink" title="第四步：更新软件源"></a>第四步：更新软件源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="第五步：开始安装ROS"><a href="#第五步：开始安装ROS" class="headerlink" title="第五步：开始安装ROS"></a>第五步：开始安装ROS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><h3 id="第六步：设置-x2F-更新环境变量"><a href="#第六步：设置-x2F-更新环境变量" class="headerlink" title="第六步：设置&#x2F;更新环境变量"></a>第六步：设置&#x2F;更新环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="第七步：安装ros所需工具"><a href="#第七步：安装ros所需工具" class="headerlink" title="第七步：安装ros所需工具"></a>第七步：安装ros所需工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosinstall python3-rosinstall-generator python3-wstool build-essential python3-roslaunch</span><br></pre></td></tr></table></figure><h2 id="二、测试是否安装成功"><a href="#二、测试是否安装成功" class="headerlink" title="二、测试是否安装成功"></a>二、测试是否安装成功</h2><h3 id="第一步：终端里输入roscore"><a href="#第一步：终端里输入roscore" class="headerlink" title="第一步：终端里输入roscore"></a>第一步：终端里输入roscore</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><h3 id="第二步：重新打开终端输入"><a href="#第二步：重新打开终端输入" class="headerlink" title="第二步：重新打开终端输入"></a>第二步：重新打开终端输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><h3 id="第三步：再重新打开终端输入"><a href="#第三步：再重新打开终端输入" class="headerlink" title="第三步：再重新打开终端输入"></a>第三步：再重新打开终端输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>把鼠标放在第三步的界面上，然后通过上下左右方向键就可以控制小海龟的移动了。<br>至此，ros已经安装完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、安装ROS-neotic步骤&quot;&gt;&lt;a href=&quot;#一、安装ROS-neotic步骤&quot; class=&quot;headerlink&quot; title=&quot;一、安装ROS neotic步骤&quot;&gt;&lt;/a&gt;一、安装ROS neotic步骤&lt;/h2&gt;&lt;h3 id=&quot;第一步：换源（在软</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS简单节点demo（Python）</title>
    <link href="https://www.clang.asia/2024/05/18/ros1%20%E7%AE%80%E5%8D%95%E8%8A%82%E7%82%B9demo%EF%BC%88Python%EF%BC%89/"/>
    <id>https://www.clang.asia/2024/05/18/ros1%20%E7%AE%80%E5%8D%95%E8%8A%82%E7%82%B9demo%EF%BC%88Python%EF%BC%89/</id>
    <published>2024-05-18T12:56:17.000Z</published>
    <updated>2025-10-28T11:39:25.132Z</updated>
    
    <content type="html"><![CDATA[<p>好的，下面是将 <code>talker_listener_demo</code> 从C++版本转换为Python版本的详细步骤和代码示例：</p><h3 id="步骤-1：创建ROS包"><a href="#步骤-1：创建ROS包" class="headerlink" title="步骤 1：创建ROS包"></a>步骤 1：创建ROS包</h3><p>在终端中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg talker_listener_demo rospy std_msgs</span><br></pre></td></tr></table></figure><p>这将在你的Catkin工作空间中创建一个名为 <code>talker_listener_demo</code> 的ROS包，并将 <code>rospy</code> 和 <code>std_msgs</code> 添加为依赖项。</p><h3 id="步骤-2：创建Python脚本"><a href="#步骤-2：创建Python脚本" class="headerlink" title="步骤 2：创建Python脚本"></a>步骤 2：创建Python脚本</h3><p>在 <code>src</code> 文件夹下创建两个Python脚本：<code>talker.py</code> 和 <code>listener.py</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/talker_listener_demo/src</span><br><span class="line"><span class="built_in">touch</span> talker.py</span><br><span class="line"><span class="built_in">touch</span> listener.py</span><br></pre></td></tr></table></figure><h3 id="步骤-3：编写Python节点代码"><a href="#步骤-3：编写Python节点代码" class="headerlink" title="步骤 3：编写Python节点代码"></a>步骤 3：编写Python节点代码</h3><p>编辑 <code>talker.py</code> 和 <code>listener.py</code> 文件，编写发布者节点和订阅者节点的Python代码。</p><h4 id="talker-py："><a href="#talker-py：" class="headerlink" title="talker.py："></a>talker.py：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talker</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;talker&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&#x27;chatter&#x27;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>) <span class="comment"># 1 Hz</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        hello_str = <span class="string">&quot;hello world %s&quot;</span> % rospy.get_time()</span><br><span class="line">        rospy.loginfo(hello_str)</span><br><span class="line">        pub.publish(hello_str)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        talker()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="listener-py："><a href="#listener-py：" class="headerlink" title="listener.py："></a>listener.py：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">data</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;I heard %s&quot;</span>, data.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listener</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;listener&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    rospy.Subscriber(<span class="string">&#x27;chatter&#x27;</span>, String, callback)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    listener()</span><br></pre></td></tr></table></figure><h3 id="步骤-4：添加依赖项到package-xml（正常应该不需要修改）"><a href="#步骤-4：添加依赖项到package-xml（正常应该不需要修改）" class="headerlink" title="步骤 4：添加依赖项到package.xml（正常应该不需要修改）"></a>步骤 4：添加依赖项到package.xml（正常应该不需要修改）</h3><p>在 <code>talker_listener_demo</code> 包的 <code>package.xml</code> 文件中添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="步骤-5：更新CMakeLists-txt"><a href="#步骤-5：更新CMakeLists-txt" class="headerlink" title="步骤 5：更新CMakeLists.txt"></a>步骤 5：更新CMakeLists.txt</h3><p>在 <code>talker_listener_demo</code> 包的 <code>CMakeLists.txt</code> 文件中确保 <code>rospy</code> 和 <code>std_msgs</code> 被正确声明为依赖项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS rospy std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>在Catkin工作空间中执行以下命令来编译ROS包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>也可以编译指定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make --only-pkg-with-deps talker_listener_demo</span><br></pre></td></tr></table></figure><p>然后，在两个不同的终端中分别运行发布者节点和订阅者节点：<br>执行前需要source一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p>同时给python脚本添加执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x talker.py</span><br><span class="line"><span class="built_in">chmod</span> +x listener.py</span><br></pre></td></tr></table></figure><p>可以用下面命令查看包是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack list|grep talker_listener_demo</span><br></pre></td></tr></table></figure><p>有时python命令不行，需要将python命令指向python3做符号链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要启动Master</span></span><br><span class="line">roscore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminal 1: Run the talker node</span></span><br><span class="line">rosrun talker_listener_demo talker.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminal 2: Run the listener node</span></span><br><span class="line">rosrun talker_listener_demo listener.py</span><br></pre></td></tr></table></figure><p>现在，你应该能够在终端中看到发布者节点发布的消息被订阅者节点成功接收并打印出来了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好的，下面是将 &lt;code&gt;talker_listener_demo&lt;/code&gt; 从C++版本转换为Python版本的详细步骤和代码示例：&lt;/p&gt;
&lt;h3 id=&quot;步骤-1：创建ROS包&quot;&gt;&lt;a href=&quot;#步骤-1：创建ROS包&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS简单节点demo（C++）</title>
    <link href="https://www.clang.asia/2024/05/17/ros1%20%E7%AE%80%E5%8D%95%E8%8A%82%E7%82%B9demo%EF%BC%88C++%EF%BC%89/"/>
    <id>https://www.clang.asia/2024/05/17/ros1%20%E7%AE%80%E5%8D%95%E8%8A%82%E7%82%B9demo%EF%BC%88C++%EF%BC%89/</id>
    <published>2024-05-17T09:56:17.000Z</published>
    <updated>2025-10-28T11:39:25.132Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个简单的 ROS 1 demo，包括创建一个 Catkin 工作空间、创建一个 ROS 节点以发布一个字符串消息到一个话题上，并创建一个订阅器来接收并打印这个消息。这个 demo 包含两个文件：<code>CMakeLists.txt</code> 和 <code>talker_listener_demo.cpp</code>。</p><p>首先，创建一个 Catkin 工作空间：</p><ol><li>打开终端。</li><li>运行以下命令，创建一个名为 <code>catkin_ws</code> 的 Catkin 工作空间： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure></li></ol><p>接下来，创建 ROS 节点和订阅器的源文件：</p><ol><li><p>在 <code>~/catkin_ws/src</code> 目录下创建一个名为 <code>talker_listener_demo</code> 的包，并进入该目录：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg talker_listener_demo roscpp std_msgs</span><br><span class="line"><span class="built_in">cd</span> talker_listener_demo</span><br></pre></td></tr></table></figure></li><li><p>在 <code>talker_listener_demo</code> 包中创建一个名为 <code>talker_listener_demo.cpp</code> 的 C++ 源文件，并在其中添加以下代码：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用于处理接收到的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 ROS 节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker_listener_demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个发布者，用于向 &quot;chatter&quot; 话题发布字符串消息</span></span><br><span class="line">  ros::Publisher chatter_pub = n.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个订阅器，用于订阅 &quot;chatter&quot; 话题的消息，并调用回调函数进行处理</span></span><br><span class="line">  ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个循环，发布消息并休眠一段时间</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; count;</span><br><span class="line">    msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确保 <code>CMakeLists.txt</code> 文件包含以下内容：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(talker_listener_demo)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 找到 catkin 并包含设置好的功能</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 包含 catkin 工程设置的头文件和库</span></span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加包含目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(talker_listener_demo src/talker_listener_demo.cpp)</span><br><span class="line"><span class="comment">## 链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(talker_listener_demo <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>构建 Catkin 工作空间：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure></li></ol><p>现在，您已经成功创建了一个简单的 ROS 节点和订阅器的 demo。要运行它，请执行以下步骤：</p><ol><li><p>在一个终端中启动 ROS Master：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></li><li><p>在另一个终端中运行 <code>talker_listener_demo</code>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br><span class="line">rosrun talker_listener_demo talker_listener_demo</span><br></pre></td></tr></table></figure></li></ol><p>您将会看到一个发布者不断地发布 “hello world” 消息，并且一个订阅器接收并打印这些消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面是一个简单的 ROS 1 demo，包括创建一个 Catkin 工作空间、创建一个 ROS 节点以发布一个字符串消息到一个话题上，并创建一个订阅器来接收并打印这个消息。这个 demo 包含两个文件：&lt;code&gt;CMakeLists.txt&lt;/code&gt; 和 &lt;code&gt;</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL日志保留策略：设置binlog日志保存天数、文件大小限制</title>
    <link href="https://www.clang.asia/2024/05/16/MySQL%E6%97%A5%E5%BF%97%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5%EF%BC%9A%E8%AE%BE%E7%BD%AEbinlog%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98%E5%A4%A9%E6%95%B0%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/"/>
    <id>https://www.clang.asia/2024/05/16/MySQL%E6%97%A5%E5%BF%97%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5%EF%BC%9A%E8%AE%BE%E7%BD%AEbinlog%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98%E5%A4%A9%E6%95%B0%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</id>
    <published>2024-05-16T02:00:05.000Z</published>
    <updated>2025-10-28T11:39:25.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、设置binlog日志保存天数、文件大小限制"><a href="#一、设置binlog日志保存天数、文件大小限制" class="headerlink" title="一、设置binlog日志保存天数、文件大小限制"></a>一、设置binlog日志保存天数、文件大小限制</h1><p>在MySQL中，有三种主要类型的日志记录：二进制日志（binlog）、错误日志和查询日志。这些日志记录对于MySQL数据库的管理和维护非常重要。在本文中，我们将重点讨论如何设置binlog日志的保留策略。</p><p>默认情况下，MySQL会自动将binlog日志文件保存在主目录或指定目录下，并且不限制binlog日志文件的大小和日志保留时间。这意味着当日志文件太大或当你不再需要它们时，你需要手动删除它们。</p><p>所以，为了优化MySQL数据库的管理，我们可以通过在MySQL配置文件my.cnf中添加以下内容来设置binlog日志的保留策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#设置日志保留天数</span><br><span class="line">expire_logs_days=7</span><br><span class="line">#设置日志文件最大大小</span><br><span class="line">max_binlog_size=100M</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上配置将保留最近7天的binlog日志文件，并且每个binlog文件的最大大小为100M。当binlog日志文件的总大小超过100M时，MySQL会自动创建一个新的binlog日志文件。当超过7天后，MySQL会自动删除所有旧的binlog日志文件。</p><p>更改设置后，需要重新启动MySQL服务才能使其生效。</p><p>注意：</p><ul><li>日志文件最大值不能设置为less than 4096 bytes。</li><li>如果你使用了“log_bin_trust_function_creators&#x3D;1” ，MySQL版本将忽略“binlog_format &#x3D; STATEMENT”，即只支持ROW模式和MIXED模式。</li></ul><h1 id="二、如何手动清理binlog"><a href="#二、如何手动清理binlog" class="headerlink" title="二、如何手动清理binlog"></a>二、如何手动清理binlog</h1><h2 id="1-使用MySQL命令行"><a href="#1-使用MySQL命令行" class="headerlink" title="1.使用MySQL命令行"></a>1.使用MySQL命令行</h2><p>在MySQL命令行中，使用PURGE BINARY LOGS语句可以删除所有指定日期前创建的过期binlog日志文件。</p><p>例如，为了删除超过7天的binlog日志文件，可以运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 7 DAY);</span><br></pre></td></tr></table></figure><h2 id="2-按照binlog名称删除"><a href="#2-按照binlog名称删除" class="headerlink" title="2.按照binlog名称删除"></a>2.按照binlog名称删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 将mysql-bin.000011之前的日志清理掉</span><br><span class="line">mysql&gt; purge binary logs to &#x27;mysql-bin.000011&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="3-按照时间删除"><a href="#3-按照时间删除" class="headerlink" title="3.按照时间删除"></a>3.按照时间删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 删除2023-03-21 18:08:00之前的binlog日志</span><br><span class="line">mysql&gt; purge binary logs before &#x27;2023-03-21 18:08:00&#x27;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、设置binlog日志保存天数、文件大小限制&quot;&gt;&lt;a href=&quot;#一、设置binlog日志保存天数、文件大小限制&quot; class=&quot;headerlink&quot; title=&quot;一、设置binlog日志保存天数、文件大小限制&quot;&gt;&lt;/a&gt;一、设置binlog日志保存天数、</summary>
      
    
    
    
    <category term="运维" scheme="https://www.clang.asia/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://www.clang.asia/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用软连接的方式修改Docker数据存储目录</title>
    <link href="https://www.clang.asia/2024/05/15/%E4%BD%BF%E7%94%A8%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.clang.asia/2024/05/15/%E4%BD%BF%E7%94%A8%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/</id>
    <published>2024-05-15T01:56:17.000Z</published>
    <updated>2025-10-28T11:39:25.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Docker 安装的东西多了或者目录分配大小未提前规划好，就容易出现磁盘空间不足的问题，可以采用软链接的方式迁移数据目录空间。</p><hr><h3 id="为什么使用符号链接？"><a href="#为什么使用符号链接？" class="headerlink" title="为什么使用符号链接？"></a>为什么使用符号链接？</h3><p>创建符号链接的好处在于，你无需修改 Docker 配置文件 <code>/etc/docker/daemon.json</code>。符号链接能够将 Docker 默认查找的数据目录路径 <code>/var/lib/docker</code> 指向新的位置，从而让 Docker 无缝找到其数据目录。</p><h3 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h3><p>按照以下步骤操作，即可成功迁移 Docker 数据目录：</p><ol><li><p><strong>停止 Docker 服务</strong></p><p>首先，确保停止 Docker 服务，以避免在复制数据时出现文件被占用的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p><strong>复制 Docker 数据目录</strong></p><p>使用 <code>cp</code> 命令复制 <code>/var/lib/docker</code> 目录到新的位置 <code>/home/app</code> 下。<code>-a</code> 选项表示归档模式，会保留文件的所有属性和权限，<code>-u</code> 表示仅在目标文件不存在或源文件更新时进行复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -au /var/lib/docker /home/app</span><br></pre></td></tr></table></figure></li><li><p><strong>重命名原始 Docker 目录</strong></p><p>为了确保数据安全，可以将原始的 Docker 目录重命名，而不是直接删除。这是一个备份步骤，以防出现意外情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /var/lib/docker /var/lib/docker.old</span><br></pre></td></tr></table></figure></li><li><p><strong>创建符号链接</strong></p><p>创建一个符号链接，将 <code>/var/lib/docker</code> 指向新的数据目录 <code>/home/app/docker</code>。这样，Docker 会继续在 <code>/var/lib/docker</code> 路径下查找数据目录，但实际上数据已经被存储在新的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /home/app/docker /var/lib/docker</span><br></pre></td></tr></table></figure></li><li><p><strong>启动 Docker 服务</strong></p><p>最后，重新启动 Docker 服务，使所有更改生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="验证迁移"><a href="#验证迁移" class="headerlink" title="验证迁移"></a>验证迁移</h3><p>迁移完成后，你可以验证 Docker 是否在新的位置正常运行。运行以下命令，查看 Docker 根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker info | grep <span class="string">&quot;Docker Root Dir&quot;</span></span><br></pre></td></tr></table></figure><p>输出应显示新的 Docker 根目录 <code>/home/app/docker</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过创建符号链接，你可以轻松地将 Docker 数据目录迁移到新的位置，而无需修改 Docker 的配置文件。这种方法简便且安全，确保 Docker 能够正确找到其数据目录，并且在整个迁移过程中不会丢失任何重要数据。</p><p>现在，Docker 将使用新的数据目录来存储数据。<br>请注意，在修改 Docker 数据目录时，需要确保新的数据目录已存在且有足够的磁盘空间可供使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Docker 安装的东西多了或者目录分配大小未提前规划好，就容易出现磁盘空间不足的问题，可以采用软链接的方式迁移数据目录空间。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="运维" scheme="https://www.clang.asia/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://www.clang.asia/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>编写与测试简单的Service和Client（Python）</title>
    <link href="https://www.clang.asia/2024/05/14/%E7%BC%96%E5%86%99%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%AE%80%E5%8D%95%E7%9A%84Service%E5%92%8CClient%EF%BC%88Python%EF%BC%89/"/>
    <id>https://www.clang.asia/2024/05/14/%E7%BC%96%E5%86%99%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%AE%80%E5%8D%95%E7%9A%84Service%E5%92%8CClient%EF%BC%88Python%EF%BC%89/</id>
    <published>2024-05-14T14:39:15.000Z</published>
    <updated>2025-10-28T11:39:25.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-导读"><a href="#01-导读" class="headerlink" title="01 导读"></a>01 导读</h1><p><strong>C++ 代码必须通过编译生成可执行文件；</strong></p><p><strong>python 代码是可执行文件，不需要编译；</strong></p><ul><li>开发的功能包都放在 catkin_ws 这样一个工作空间里；</li><li>新建的功能包取名为 service_example，实现两个整数求和为例，client 端节点向 server 端节点发送 a、b 的请求，server 端节点返回响应 sum&#x3D;a+b 给 client 端节点；</li></ul><p><strong>服务编程流程</strong></p><ul><li>创建服务器</li><li>创建客户端</li><li>添加编译选项</li><li>运行可执行程序</li></ul><h1 id="02-功能包的创建"><a href="#02-功能包的创建" class="headerlink" title="02 功能包的创建"></a>02 功能包的创建</h1><p>在 catkin_ws&#x2F;src&#x2F; 目录下新建功能包 service_example，并在创建时显式的指明依赖 rospy 和 std_msgs，依赖 std_msgs 将作为基本数据类型用于定义我们的服务类型。打开命令行终端，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line"></span><br><span class="line"># 创建功能包 topic_example 时，显式的指明依赖 rospy 和 std_msgs，</span><br><span class="line"># 依赖会被默认写到功能包的 CMakeLists.txt 和 package.xml 中</span><br><span class="line">$ catkin_create_pkg service_example rospy std_msgs</span><br></pre></td></tr></table></figure><h1 id="03-在功能包中创建自定义服务类型"><a href="#03-在功能包中创建自定义服务类型" class="headerlink" title="03 在功能包中创建自定义服务类型"></a>03 在功能包中创建自定义服务类型</h1><ul><li>服务(srv): 一个 srv 文件描述一项服务。它包含两个部分：请求和响应。</li></ul><p><em>服务类型的定义文件都是以</em>.srv 为扩展名，srv 文件则存放在功能包的 srv 目录下。</p><ul><li>服务通信过程中服务的数据类型需要用户自己定义，与消息不同，节点并不提供标准服务类型。</li></ul><h2 id="3-1-定义-srv-文件"><a href="#3-1-定义-srv-文件" class="headerlink" title="3.1 定义 srv 文件"></a>3.1 定义 srv 文件</h2><p>srv 文件分为请求和响应两部分，由 ‘—‘ 分隔。</p><p>在功能包 service_example 目录下新建 srv 目录，然后在 service_example&#x2F;srv&#x2F; 目录中创建 AddTwoInts.srv 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p>其中<code>a</code>和<code>b</code>是请求，而<code>sum</code> 是响应。</p><h2 id="3-2-在-package-xml-中添加功能包依赖"><a href="#3-2-在-package-xml-中添加功能包依赖" class="headerlink" title="3.2 在 package.xml 中添加功能包依赖"></a>3.2 在 package.xml 中添加功能包依赖</h2><p>srv 文件被转换成为 C++，Python 和其他语言的源代码：</p><p>查看 <code>package.xml</code>, 确保它包含一下两条语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>如果没有，添加进去。 注意，在构建的时候，我们只需要”message_generation”。然而，在运行的时候，我们只需要”message_runtime”。</p><h2 id="3-3-在-CMakeLists-txt-添加编译选项"><a href="#3-3-在-CMakeLists-txt-添加编译选项" class="headerlink" title="3.3 在 CMakeLists.txt 添加编译选项"></a>3.3 在 CMakeLists.txt 添加编译选项</h2><p><strong>第一步，增加 message_generation</strong></p><p>打开功能包中的 CMakeLists.txt 文件，利用 find_packag 函数，增加对 <code>message_generation</code> 的依赖，这样就可以生成消息了。 你可以直接在 <code>COMPONENTS</code> 的列表里增加 <code>message_generation</code>，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>有时候你会发现，即使你没有调用 find_package, 你也可以编译通过。这是因为 catkin 把你所有的功能包都整合在一起，因此，如果其他的功能包调用了 find_package，你的功能包的依赖就会是同样的配置。但是，在你单独编译时，忘记调用 find_package 会很容易出错。</p><p><strong>第二步，删掉 <code>#</code>，去除对下边语句的注释:</strong></p><p>找到如下代码块:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># add_service_files(</span><br><span class="line">#   FILES</span><br><span class="line">#   Service1.srv</span><br><span class="line">#   Service2.srv</span><br><span class="line"># )</span><br></pre></td></tr></table></figure><p>用你自己定义的 srv 文件名（AddTwoInts.srv）替换掉那些<code>Service*.srv</code>文件，修改好后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  AddTwoInts.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>第三步，msg 和 srv 都需要的步骤</strong></p><p>在 <code>CMakeLists.txt</code> 中找到如下部分:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># generate_messages(</span><br><span class="line">#   DEPENDENCIES</span><br><span class="line"># #  std_msgs  # Or other packages containing msgs</span><br><span class="line"># )</span><br></pre></td></tr></table></figure><p>去掉注释并附加上所有你消息文件所依赖的那些含有<code>.msg</code>文件的功能包（这个例子是依赖<code>std_msgs</code>, 不要添加 roscpp,rospy)，结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>原因：generate_messages 的作用是自动创建我们自定义的消息类型 .msg 与服务类型 .srv 相对应的 .h，由于我们定义的服务类型使用了 std_msgs 中的 int64 基本类型，所以必须向 generate_messages 指明该依赖。</p><p><strong>第四步，由于增加了新的消息，所以我们需要重新编译我们的功能包：</strong></p><p>目的：查看配置是否有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ catkin_make -DCATKIN_WHITELIST_PACKAGES=&quot;service_example&quot;</span><br></pre></td></tr></table></figure><p>所有在 msg 路径下的.msg 文件都将转换为 ROS 所支持语言的源代码。生成的 C++ 头文件将会放置在<code>~/catkin_ws/devel/include/service_example/</code>。 Python 脚本语言会在<code>~/catkin_ws/devel/lib/python2.7/dist-packages/service_example/msg</code> 目录下创建。</p><h1 id="04-查看自定义的服务消息"><a href="#04-查看自定义的服务消息" class="headerlink" title="04 查看自定义的服务消息"></a>04 查看自定义的服务消息</h1><p>通过 &lt;功能包名 &#x2F; 服务类型名&gt; 找到该服务，打开命令行终端，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/catkin_ws/devel/setup.bash</span><br><span class="line"></span><br><span class="line">$ rossrv show service_example/AddTwoInts</span><br></pre></td></tr></table></figure><h1 id="05-功能包的源代码编写"><a href="#05-功能包的源代码编写" class="headerlink" title="05 功能包的源代码编写"></a>05 功能包的源代码编写</h1><p>功能包中需要编写两个独立可执行的节点，一个节点用来作为 client 端发起请求，另一个节点用来作为 server 端响应请求，所以需要在新建的功能包 service_example&#x2F;scripts 目录下新建两个文件 server.py 和 client.py，并将下面的代码分别填入。</p><h2 id="5-1-编写-Service-节点（server-py）"><a href="#5-1-编写-Service-节点（server-py）" class="headerlink" title="5.1 编写 Service 节点（server.py）"></a>5.1 编写 Service 节点（server.py）</h2><p>将创建一个简单的 service 节点(“server”)，该节点将接收到两个整形数字，并返回它们的和。</p><p><strong>如何实现一个服务器</strong></p><ul><li>初始化 ROS 节点；</li><li>创建 Server 实例；</li><li>循环等待服务请求，进入回调函数；</li><li>在回调函数中完成服务功能的处理，并反馈应答数据。</li></ul><p>在 service_example 包中创建 scripts &#x2F;server.py 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> service_example.srv <span class="keyword">import</span> AddTwoInts,AddTwoIntsResponse</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_add_two_ints</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Returning [%s + %s = %s]&quot;</span>%(req.a, req.b, (req.a + req.b)))</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#因为我们已经将服务的类型声明为AddTwoInts，所以它会为您生成AddTwoIntsRequest对象（可以自由传递）</span></span><br><span class="line">    <span class="keyword">return</span> AddTwoIntsResponse(req.a + req.b)    <span class="comment"># AddTwoIntsResponse由服务生成的返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_server</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;add_two_ints_server&#x27;</span>)  <span class="comment"># 声明节点为add_two_ints_server</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">#定义服务器节点名称，服务类型，处理函数</span></span><br><span class="line">        <span class="comment">#处理函数调用实例化的AddTwoIntsRequest接收请求和返回实例化的AddTwoIntsResponse</span></span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Ready to add two ints.&quot;</span>)</span><br><span class="line">    rospy.spin()   <span class="comment"># 就像订阅者示例一样，rospy.spin()使代码不会退出，直到服务关闭；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    add_two_ints_server()</span><br></pre></td></tr></table></figure><p>在～&#x2F;catkin_ws&#x2F;src&#x2F;service_example 下，让节点可执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x scripts/server.py</span><br></pre></td></tr></table></figure><h2 id="5-2-编写-Client-节点（client-py）"><a href="#5-2-编写-Client-节点（client-py）" class="headerlink" title="5.2 编写 Client 节点（client.py）"></a>5.2 编写 Client 节点（client.py）</h2><p><strong>如何实现一个客户端</strong></p><ul><li>初始化 ROS 节点；</li><li>创建一个 Client 实例；</li><li>发布服务请求数据；</li><li>等待 Server 处理之后的应答结果。</li></ul><p>在 service_example 包中创建 scripts &#x2F;client.py 文件，并在其中粘贴以下內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">导入sys模块，sys.argv的功能是在外部向程序的内部传递参数。sys.argv(number)，number=0的时候是脚本的名称</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_example.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 等待服务节点的接入</span></span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;add_two_ints&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="comment"># 创建服务的处理句柄，可以像调用函数一样调用句柄</span></span><br><span class="line">        add_two_ints = rospy.ServiceProxy(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts)</span><br><span class="line">        <span class="comment"># 创建服务请求对象</span></span><br><span class="line">        request = AddTwoIntsRequest()</span><br><span class="line">        request.a = x</span><br><span class="line">        request.b = y</span><br><span class="line">        <span class="comment"># 调用服务并获取响应</span></span><br><span class="line">        resp = add_two_ints(request)</span><br><span class="line">        <span class="comment"># 返回响应中的和</span></span><br><span class="line">        <span class="keyword">return</span> resp.<span class="built_in">sum</span> </span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 如果调用失败，可能会抛出rospy.ServiceException</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Service call failed: %s&quot;</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%s [x y]&quot;</span> % sys.argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(usage())</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Requesting %s + %s&quot;</span> % (x, y))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span> % (x, y, add_two_ints_client(x, y)))</span><br></pre></td></tr></table></figure><p>在～&#x2F;catkin_ws&#x2F;src&#x2F;service_example 节点可执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x scripts/client.py</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><p>我们可以像普通函数一样使用这个句柄并调用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp1 = add_two_ints(x, y)</span><br><span class="line">return resp1.sum</span><br></pre></td></tr></table></figure><p>因为我们已经将服务的类型声明为 AddTwoInts，所以它会为你生成 AddTwoIntsRequest 对象(可以自由传递)。返回值是 AddTwoIntsResponse 对象。如果调用失败，可能会抛出 rospy.ServiceException，因此你应该设置适当的 try&#x2F;except 块。</p><h1 id="06-功能包的编译"><a href="#06-功能包的编译" class="headerlink" title="06 功能包的编译"></a>06 功能包的编译</h1><p>我们使用 CMake 作为构建系统，是的，即使是 Python 节点也必须使用它。这是为了确保创建消息和服务时自动生成 Python 代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ catkin_make -DCATKIN_WHITELIST_PACKAGES=&quot;service_example&quot;</span><br></pre></td></tr></table></figure><h1 id="07-测试-service-和-client"><a href="#07-测试-service-和-client" class="headerlink" title="07 测试 service 和 client"></a>07 测试 service 和 client</h1><h2 id="7-1-运行-Service"><a href="#7-1-运行-Service" class="headerlink" title="7.1 运行 Service"></a>7.1 运行 Service</h2><p>第一步，打开一个命令行终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure><p>第二步，打开第二个命令行终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 用 rosrun &lt;package_name&gt; &lt;node_name&gt; 启动功能包中的发布节点。</span><br><span class="line">$ source ~/catkin_ws/devel/setup.bash    # 激活 catkin_ws 工作空间（必须有，必不可少）</span><br><span class="line">$ rosrun service_example server.py       # (python 版本)</span><br></pre></td></tr></table></figure><p>你将看到如下的输出信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ready to add two ints.              # Server 节点启动后的日志信息</span><br></pre></td></tr></table></figure><h2 id="7-2-运行-Client"><a href="#7-2-运行-Client" class="headerlink" title="7.2 运行 Client"></a>7.2 运行 Client</h2><p>现在，运行 Client 并附带一些参数：</p><p>打开第三个命令行客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/catkin_ws/devel/setup.bash     # 激活 catkin_ws 工作空间（必须有，必不可少）</span><br><span class="line">$ rosrun service_example client.py 1 3    # (Python)</span><br></pre></td></tr></table></figure><p>你将会看到如下的输出信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Client 启动后发布服务请求，并成功接收到反馈结果</span><br><span class="line">Requesting 1+3</span><br><span class="line">1 + 3 = 4</span><br><span class="line"></span><br><span class="line"># Server 接收到服务调用后完成加法求解，并将结果反馈给 Client</span><br><span class="line">Returning [1 + 3 = 4]</span><br></pre></td></tr></table></figure><p>现在，你已经成功地运行了你的第一个 Service 和 Client 程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-导读&quot;&gt;&lt;a href=&quot;#01-导读&quot; class=&quot;headerlink&quot; title=&quot;01 导读&quot;&gt;&lt;/a&gt;01 导读&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;C++ 代码必须通过编译生成可执行文件；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pytho</summary>
      
    
    
    
    <category term="ROS" scheme="https://www.clang.asia/categories/ROS/"/>
    
    
    <category term="ROS" scheme="https://www.clang.asia/tags/ROS/"/>
    
  </entry>
  
</feed>
